{
  "models_tested": [
    "qwen2.5-coder:3b",
    "qwen2.5-coder:1.5b",
    "llama2:latest",
    "qwen2.5-coder:7b"
  ],
  "test_queries": [
    "How do I implement a combat system in LPC?",
    "Show me the correct syntax for query_* functions",
    "What's the difference between call_other() and call_out()?",
    "Generate a basic room inherit for the std/room.c",
    "How does the LPC object inheritance system work?"
  ],
  "results": [
    {
      "model_name": "qwen2.5-coder:3b",
      "query": "How do I implement a combat system in LPC?",
      "response": "To implement a combat system in LPC following MudOS/FluffOS patterns, you can follow these steps:\n\n1. **Understand the Basics**: Familiarize yourself with basic LPC concepts such as objects, properties, functions, and inheritance.\n\n2. **Design the Combat System**:\n   - Decide on how your combat will work (e.g., turn-based, real-time).\n   - Define the necessary properties for characters (health, attack power, defense, etc.).\n   - Create a function to handle attacks and damage calculations.\n   - Implement a system to track turns or rounds.\n\n3. **Implement Combat Functions**:\n   - Write functions to calculate damage based on attacker's attack power and defender's defense.\n   - Implement a function to update character health after an attack.\n   - Create a function to check if a character is alive (health > 0).\n\n4. **Use Master Hooks**: Ensure that your combat system respects master hooks for security and permissions.\n\n5. **Keep Outputs Self-contained**: Only include code that is directly referenced in the snippets retrieved from the references.\n\n6. **Generate Code**:\n   - Use CALL_METHOD/OP_SUPER_CALL to call functions on objects.\n   - Traverse the Abstract Syntax Tree (AST) recursively if needed, but ensure it doesn't introduce unnecessary complexity.\n\n7. **Return Complete C Code**: Ensure the code is complete and can be compiled without errors. Include clear headers and no placeholder TODOs.\n\nHere's a basic example of how you might implement a combat system in LPC:\n\n```lpc\n// Define character properties\nstruct Character {\n    int health;\n    int attack_power;\n    int defense;\n};\n\n// Function to calculate damage\nint calculate_damage(struct Character *attacker, struct Character *defender) {\n    int base_damage = attacker->attack_power - defender->defense;\n    return max(base_damage, 0);\n}\n\n// Function to update character health\nvoid update_health(struct Character *character, int damage) {\n    character->health -= damage;\n}\n\n// Function to check if a character is alive\nint is_alive(struct Character *character) {\n    return character->health > 0;\n}\n\n// Combat function\nvoid combat(struct Character *attacker, struct Character *defender) {\n    int damage = calculate_damage(attacker, defender);\n    update_health(defender, damage);\n    message(\"You hit the enemy for %d damage!\", damage);\n\n    if (!is_alive(defender)) {\n        message(\"The enemy has been defeated!\");\n    }\n}\n\n// Example usage\nvoid main() {\n    struct Character player = {100, 20, 5};\n    struct Character enemy = {80, 15, 10};\n\n    combat(&player, &enemy);\n}\n```\n\n### Explanation:\n- **Character Structure**: Defines the properties of a character.\n- **calculate_damage Function**: Calculates the damage based on attack power and defense.\n- **update_health Function**: Updates the character's health after an attack.\n- **is_alive Function**: Checks if a character is still alive.\n- **combat Function**: Handles the combat logic, including calculating damage and updating character health.\n- **Example Usage**: Demonstrates how to use the combat system in a simple main function.\n\nThis example follows MudOS/FluffOS patterns by using basic LPC concepts and functions. Make sure to adapt it to your specific needs and integrate it into your existing driver or mudlib structure.",
      "response_time_ms": 11339,
      "tokens_per_second": 52.507935,
      "validation_result": {
        "query": "How do I implement a combat system in LPC?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "relevance_score": 0.55,
            "snippet": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "line_number": 292,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "relevance_score": 0.55,
            "snippet": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "line_number": 550,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "relevance_score": 0.55,
            "snippet": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "line_number": 4,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "relevance_score": 0.55,
            "snippet": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "line_number": 3,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "relevance_score": 0.35000002,
            "snippet": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "line_number": 47,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "line_number": 49,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.7540002,
        "validation_score": 0.828,
        "sources_consulted": 25,
        "efuns_found": [
          "EQ",
          "GE",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 104",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "code": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "context": "From FluffOS at line 292",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "code": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "context": "From FluffOS at line 550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "code": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "context": "From FluffOS at line 4",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "code": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "context": "From FluffOS at line 3",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "code": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "context": "From DGD at line 22",
            "driver": "DGD"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "context": "From Unknown at line 47",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "context": "From Unknown at line 49",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 0.75,
      "quality_score": 0.72048575,
      "timestamp": "2026-01-25T17:32:13.419893300+00:00"
    },
    {
      "model_name": "qwen2.5-coder:3b",
      "query": "Show me the correct syntax for query_* functions",
      "response": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Function to query the current time in seconds since epoch\nint query_time() {\n    return (int)time(NULL);\n}\n\n// Function to check if a given string is empty\nint query_empty_string(const char *str) {\n    return str == NULL || strlen(str) == 0;\n}\n\n// Function to get the length of a given string\nint query_strlen(const char *str) {\n    return strlen(str);\n}\n\n// Function to convert an integer to a string\nchar* query_int_to_str(int num) {\n    char *str = (char*)malloc(12); // Assuming max int is 10 digits long + null terminator\n    sprintf(str, \"%d\", num);\n    return str;\n}\n\n// Function to compare two strings for equality\nint query_strcmp(const char *a, const char *b) {\n    return strcmp(a, b);\n}\n\n// Function to get the current date in a format like \"YYYY-MM-DD\"\nchar* query_current_date() {\n    // Implementation would depend on platform and library used\n    // Here we assume a simple implementation for demonstration purposes\n    char *date = (char*)malloc(12); // Assuming max date length is 10 characters + null terminator\n    sprintf(date, \"YYYY-MM-DD\");\n    return date;\n}\n\n// Function to get the current user's home directory\nchar* query_home_directory() {\n    // Implementation would depend on platform and library used\n    // Here we assume a simple implementation for demonstration purposes\n    char *home = (char*)malloc(1024); // Assuming max path length is 1023 characters + null terminator\n    sprintf(home, \"/home/user\");\n    return home;\n}\n\n// Function to get the current working directory\nchar* query_working_directory() {\n    // Implementation would depend on platform and library used\n    // Here we assume a simple implementation for demonstration purposes\n    char *cwd = (char*)malloc(1024); // Assuming max path length is 1023 characters + null terminator\n    sprintf(cwd, \"/current/directory\");\n    return cwd;\n}\n\n// Function to get the current system's hostname\nchar* query_hostname() {\n    // Implementation would depend on platform and library used\n    // Here we assume a simple implementation for demonstration purposes\n    char *hostname = (char*)malloc(128); // Assuming max hostname length is 127 characters + null terminator\n    sprintf(hostname, \"localhost\");\n    return hostname;\n}\n\n// Function to get the current system's uptime in seconds\nint query_uptime() {\n    // Implementation would depend on platform and library used\n    // Here we assume a simple implementation for demonstration purposes\n    return (int)time(NULL);\n}\n\n// Function to check if a given file exists\nint query_file_exists(const char *path) {\n    FILE *file = fopen(path, \"r\");\n    int exists = file != NULL;\n    fclose(file);\n    return exists;\n}\n\n// Function to get the size of a file in bytes\nlong query_file_size(const char *path) {\n    FILE *file = fopen(path, \"rb\");\n    if (file == NULL) {\n        return -1; // Error opening file\n    }\n    fseek(file, 0L, SEEK_END);\n    long size = ftell(file);\n    fclose(file);\n    return size;\n}\n\n// Function to get the current process ID\npid_t query_process_id() {\n    return getpid();\n}\n\n// Function to get the current thread ID (not available in all platforms)\npthread_t query_thread_id() {\n    pthread_t tid;\n    pthread_self(&tid);\n    return tid;\n}\n```\n\nThis code provides a set of functions that mimic the behavior of `query_*` functions commonly found in MudOS/FluffOS, adhering to the specified guidelines. Each function is self-contained and returns the requested information in a clear format.",
      "response_time_ms": 9612,
      "tokens_per_second": 68.16286,
      "validation_result": {
        "query": "Show me the correct syntax for query_* functions",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "line_number": 4636,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "relevance_score": 0.57857144,
            "snippet": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "line_number": 1105,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "relevance_score": 0.57857144,
            "snippet": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "line_number": 540,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "line_number": 2187,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "relevance_score": 0.57857144,
            "snippet": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "line_number": 71,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "relevance_score": 0.57857144,
            "snippet": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "line_number": 145,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "relevance_score": 0.57857144,
            "snippet": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "line_number": 27,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "line_number": 31,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "line_number": 35,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "line_number": 59,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "line_number": 25,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "relevance_score": 0.57857144,
            "snippet": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "line_number": 1153,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "relevance_score": 0.57857144,
            "snippet": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "line_number": 280,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "line_number": 109,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "line_number": 57,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "line_number": 23,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "relevance_score": 0.57857144,
            "snippet": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "line_number": 18,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "line_number": 17,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.62657136,
        "validation_score": 0.39600003,
        "sources_consulted": 25,
        "efuns_found": [
          "LE",
          "LOG",
          "NE",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "context": "From FluffOS at line 4636",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "code": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "context": "From FluffOS at line 1105",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "code": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "context": "From FluffOS at line 540",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "code": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "context": "From FluffOS at line 2187",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "code": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "context": "From FluffOS at line 71",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "code": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "context": "From Unknown at line 145",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "code": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "context": "From Unknown at line 1",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 31",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "code": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "context": "From Unknown at line 59",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "code": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "context": "From Unknown at line 25",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "code": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "context": "From Unknown at line 1153",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "code": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "context": "From Unknown at line 280",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "code": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "context": "From Unknown at line 57",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "code": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "context": "From Unknown at line 23",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "code": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "code": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "context": "From Unknown at line 22",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "code": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "context": "From Unknown at line 18",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "code": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "context": "From Unknown at line 17",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 1.0,
      "quality_score": 0.62511426,
      "timestamp": "2026-01-25T17:32:23.032202200+00:00"
    },
    {
      "model_name": "qwen2.5-coder:3b",
      "query": "What's the difference between call_other() and call_out()?",
      "response": "To provide a detailed explanation and example of the differences between `call_other()` and `call_out()`, we need to understand their primary purposes, usage scenarios, and how they interact with the virtual machine (VM) in an LPC driver.\n\n### call_other()\n\n`call_other()` is used to invoke a function on another object. It allows for communication between objects by calling methods defined in other objects. This is particularly useful for implementing features like remote procedure calls or shared functionality across different parts of a game world.\n\n#### Key Features:\n- **Function Invocation**: Invokes a function on another object.\n- **Arguments**: Can pass arguments to the called function.\n- **Return Value**: Returns the result of the function call.\n- **Scope**: Function is executed in the context of the calling object, not the target object.\n\n#### Usage Example:\nSuppose we have two objects: `obj1` and `obj2`. We want to call a function `do_something()` on `obj2` from `obj1`.\n\n```c\nint result = call_other(obj2, \"do_something\", arg1, arg2);\n```\n\n### call_out()\n\n`call_out()` is used to schedule a function to be called at a later time. It allows for asynchronous execution of functions, which can be useful for implementing delayed actions or periodic tasks.\n\n#### Key Features:\n- **Function Scheduling**: Schedules a function to be called after a specified delay.\n- **Arguments**: Can pass arguments to the scheduled function.\n- **Return Value**: Returns an identifier (often an integer) that can be used to cancel the call_out if needed.\n- **Scope**: Function is executed in the context of the calling object, not the target object.\n\n#### Usage Example:\nSuppose we want to schedule a function `do_something_later()` on `obj1` to be called after 5 seconds.\n\n```c\nint call_out_id = call_out(\"do_something_later\", 5, arg1, arg2);\n```\n\n### Differences\n\n1. **Execution Timing**:\n   - `call_other()`: Executes immediately when called.\n   - `call_out()`: Schedules execution at a later time.\n\n2. **Scope and Context**:\n   - Both functions execute in the context of the calling object.\n   - However, `call_out()` allows for asynchronous execution, which can be more efficient for tasks that don't need to block other operations.\n\n3. **Return Value**:\n   - `call_other()`: Returns the result of the function call.\n   - `call_out()`: Returns an identifier that can be used to cancel the call_out if needed.\n\n4. **Usage Scenarios**:\n   - Use `call_other()` for communication between objects or shared functionality.\n   - Use `call_out()` for scheduling delayed actions, periodic tasks, or asynchronous operations.\n\n### Example Code\n\nHere's a simple example demonstrating both functions in an LPC driver:\n\n```c\n// Function to be called by call_other()\nint do_something(object obj) {\n    write(\"do_something() was called on \" + obj->query_name());\n    return 1;\n}\n\n// Function to be called by call_out()\nvoid do_something_later(object obj, int delay) {\n    write(\"do_something_later() was called after \" + delay + \" seconds.\");\n}\n\nint main() {\n    object obj1 = clone_object(\"/path/to/object1\");\n    object obj2 = clone_object(\"/path/to/object2\");\n\n    // Call a function on another object\n    call_other(obj1, \"do_something\", obj2);\n\n    // Schedule a function to be called later\n    int call_out_id = call_out(\"do_something_later\", 5, obj1);\n\n    return 0;\n}\n```\n\nIn this example:\n- `do_something()` is called immediately on `obj2` using `call_other()`.\n- `do_something_later()` is scheduled to be called after 5 seconds on `obj1` using `call_out()`.\n\nThis demonstrates the primary differences between `call_other()` and `call_out()` in an LPC driver, highlighting their respective use cases and execution timing.",
      "response_time_ms": 25744,
      "tokens_per_second": 27.015362,
      "validation_result": {
        "query": "What's the difference between call_other() and call_out()?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "relevance_score": 0.72142863,
            "snippet": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "line_number": 10,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "line_number": 85,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "line_number": 93,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "line_number": 102,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "line_number": 157,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "line_number": 230,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "line_number": 246,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.9048573,
        "validation_score": 0.804,
        "sources_consulted": 25,
        "efuns_found": [
          "CALL_OTHER",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "code": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "code": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "context": "From FluffOS at line 10",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From MudOS at line 36",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From MudOS at line 35",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From FluffOS at line 109",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "context": "From FluffOS at line 85",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "context": "From FluffOS at line 93",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "context": "From FluffOS at line 157",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "context": "From FluffOS at line 230",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "context": "From FluffOS at line 246",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 1.0,
      "quality_score": 0.7371715,
      "timestamp": "2026-01-25T17:32:48.776863800+00:00"
    },
    {
      "model_name": "qwen2.5-coder:3b",
      "query": "Generate a basic room inherit for the std/room.c",
      "response": "To generate a basic room inherit for the `std/room.c` file, you can create a new file named `basic_room.c` and add the following code:\n\n```c\ninherit \"/std/room\";\n\nvoid setup() {\n    set_short(\"A Basic Room\");\n    set_long(\n        \"This is a simple room with basic features. You can move around freely here.\"\n    );\n    set_light(10); // Set the light level to 10\n}\n```\n\n### Explanation:\n\n- **Inherit**: The `inherit \"/std/room\";` line tells the compiler that this file inherits from the `/std/room.c` file, which provides basic room functionality.\n  \n- **setup() Function**: This function is called when a new instance of the room is created. It sets up various properties of the room:\n  - `set_short(\"A Basic Room\");`: Sets the short description of the room, which appears in the player's inventory or when they type `look`.\n  - `set_long(...);`: Provides a detailed description of the room that appears when the player types `look` in the room.\n  - `set_light(10);`: Sets the light level to 10. The value can range from 0 (complete darkness) to 255 (full sunlight).\n\nThis basic setup ensures that your rooms have a simple structure and are ready for further customization or extension. You can add more features such as items, exits, and other room properties by calling additional functions like `add_item()`, `add_exit()`, etc., within the `setup()` function or in other methods of the class.",
      "response_time_ms": 15720,
      "tokens_per_second": 18.027624,
      "validation_result": {
        "query": "Generate a basic room inherit for the std/room.c",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "relevance_score": 0.72142863,
            "snippet": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "line_number": 0,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "line_number": 222,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "relevance_score": 0.57857144,
            "snippet": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "line_number": 2555,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.57857144,
            "snippet": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "line_number": 2384,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "line_number": 2945,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 655,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 819,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "relevance_score": 0.57857144,
            "snippet": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "line_number": 643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "relevance_score": 0.57857144,
            "snippet": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "line_number": 16,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "line_number": 202,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "line_number": 357,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "line_number": 54,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "line_number": 89,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "relevance_score": 0.57857144,
            "snippet": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "line_number": 27,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "relevance_score": 0.57857144,
            "snippet": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "line_number": 32,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "line_number": 325,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "line_number": 331,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "line_number": 338,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "line_number": 9,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "relevance_score": 0.57857144,
            "snippet": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "line_number": 29,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "relevance_score": 0.57857144,
            "snippet": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "line_number": 88,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "line_number": 101,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "line_number": 108,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "line_number": 120,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.6622856,
        "validation_score": 0.46800002,
        "sources_consulted": 25,
        "efuns_found": [
          "GE",
          "LE",
          "MOD",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "code": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "context": "From FluffOS at line 0",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "context": "From FluffOS at line 222",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "code": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "context": "From FluffOS at line 2555",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "context": "From FluffOS at line 2384",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "context": "From FluffOS at line 2945",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 819",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "code": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "context": "From FluffOS at line 643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "code": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "context": "From FluffOS at line 16",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "context": "From FluffOS at line 202",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "context": "From FluffOS at line 357",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "code": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "context": "From Unknown at line 54",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "code": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "context": "From Unknown at line 89",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "code": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "code": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "context": "From Unknown at line 32",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "context": "From Unknown at line 325",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "context": "From Unknown at line 331",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "context": "From Unknown at line 338",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "code": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "code": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "context": "From Unknown at line 29",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "code": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "code": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "context": "From Unknown at line 88",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "context": "From Unknown at line 101",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "context": "From Unknown at line 108",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "context": "From Unknown at line 120",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 1.0,
      "quality_score": 0.7258286,
      "timestamp": "2026-01-25T17:33:04.497220500+00:00"
    },
    {
      "model_name": "qwen2.5-coder:3b",
      "query": "How does the LPC object inheritance system work?",
      "response": "To implement an LPC object inheritance system in C, we need to define a structure for objects and provide functions for creating, cloning, and managing inheritance relationships. Here's a basic implementation:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define TAG_TEMPORARY 1\n\ntypedef struct {\n    char *name;\n    void (*init)(void);\n} object_type_t;\n\ntypedef struct {\n    object_type_t *type;\n    int ref_count;\n    // Additional fields for object properties\n    int flags; // Flags like cloned, swapped\n    time_t timestamp;\n    // Pointers to children/owners for hierarchical cleanup\n    struct object_t *parent;\n    struct object_t **children;\n    int num_children;\n} object_t;\n\n// Function to initialize an object type\nvoid init_object_type(object_type_t *type) {\n    type->init = NULL;\n}\n\n// Function to create a new object of a given type\nobject_t *create_object(object_type_t *type) {\n    object_t *obj = (object_t *)malloc(sizeof(object_t));\n    if (!obj) return NULL;\n\n    obj->type = type;\n    obj->ref_count = 1;\n    obj->flags = 0;\n    obj->timestamp = time(NULL);\n    obj->parent = NULL;\n    obj->children = NULL;\n    obj->num_children = 0;\n\n    // Initialize the object\n    if (type->init) {\n        type->init();\n    }\n\n    return obj;\n}\n\n// Function to clone an object\nobject_t *clone_object(object_t *obj) {\n    object_t *new_obj = create_object(obj->type);\n    if (!new_obj) return NULL;\n\n    // Copy properties and children\n    new_obj->ref_count = 1; // Increment ref count for the new object\n    new_obj->flags = obj->flags;\n    new_obj->timestamp = time(NULL);\n\n    // Clone children (if any)\n    if (obj->num_children > 0) {\n        new_obj->children = (object_t **)malloc(obj->num_children * sizeof(object_t *));\n        if (!new_obj->children) return NULL;\n\n        for (int i = 0; i < obj->num_children; i++) {\n            new_obj->children[i] = clone_object(obj->children[i]);\n            if (!new_obj->children[i]) {\n                // Free partially cloned object\n                free(new_obj);\n                return NULL;\n            }\n        }\n\n        new_obj->num_children = obj->num_children;\n    }\n\n    return new_obj;\n}\n\n// Function to add a child to an object\nvoid add_child(object_t *parent, object_t *child) {\n    if (parent && child) {\n        parent->children[parent->num_children++] = child;\n        child->parent = parent;\n    }\n}\n\n// Function to remove a child from an object\nvoid remove_child(object_t *parent, object_t *child) {\n    if (parent && child) {\n        for (int i = 0; i < parent->num_children; i++) {\n            if (parent->children[i] == child) {\n                // Shift children to fill the gap\n                for (int j = i; j < parent->num_children - 1; j++) {\n                    parent->children[j] = parent->children[j + 1];\n                }\n                parent->children[parent->num_children - 1] = NULL;\n                parent->num_children--;\n                break;\n            }\n        }\n    }\n}\n\n// Function to free an object\nvoid free_object(object_t *obj) {\n    if (obj) {\n        // Free children first\n        for (int i = 0; i < obj->num_children; i++) {\n            free_object(obj->children[i]);\n        }\n\n        // Free other resources if needed\n\n        // Decrement ref count and free object if no more references\n        if (--obj->ref_count == 0) {\n            free(obj);\n        }\n    }\n}\n\nint main() {\n    // Example usage\n    object_type_t type1 = { \"type1\", NULL };\n    init_object_type(&type1);\n\n    object_type_t type2 = { \"type2\", NULL };\n    init_object_type(&type2);\n\n    object_t *obj1 = create_object(&type1);\n    object_t *obj2 = clone_object(obj1);\n    add_child(obj1, obj2);\n\n    printf(\"Object 1 name: %s\\n\", obj1->name);\n    printf(\"Object 2 name: %s\\n\", obj2->name);\n\n    free_object(obj1);\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Object Structure**: The `object_t` structure contains:\n   - A pointer to the object type.\n   - Reference count for memory management.\n   - Additional properties like flags, timestamp, and pointers to parent and children.\n\n2. **Initialization**: The `init_object_type` function initializes an object type with a pointer to its initialization function.\n\n3. **Creation**: The `create_object` function allocates memory for a new object, initializes it with the given type, and calls the type's initialization function if present.\n\n4. **Cloning**: The `clone_object` function creates a deep copy of an object, including all children, to maintain inheritance relationships.\n\n5. **Inheritance Management**: Functions like `add_child` and `remove_child` allow you to manage child objects for inheritance.\n\n6. **Memory Management**: The `free_object` function decrements the reference count and frees the object when no more references are left.\n\nThis implementation provides a basic framework for managing LPC-like objects with inheritance, which can be expanded with additional features like property management, serialization, and error handling as needed.",
      "response_time_ms": 20623,
      "tokens_per_second": 38.702908,
      "validation_result": {
        "query": "How does the LPC object inheritance system work?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "line_number": 1299,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1376,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "line_number": 1383,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1455,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "line_number": 1462,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "line_number": 1550,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "line_number": 1643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "line_number": 1655,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "line_number": 1816,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "line_number": 1836,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "line_number": 1877,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "line_number": 1878,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "line_number": 1962,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "line_number": 1982,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "line_number": 2018,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "line_number": 2073,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "line_number": 8,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "line_number": 11,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "line_number": 78,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "line_number": 107,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "line_number": 191,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "relevance_score": 0.6,
            "snippet": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "line_number": 50,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "line_number": 79,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "relevance_score": 0.6,
            "snippet": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "line_number": 17,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.61800015,
        "validation_score": 0.33600003,
        "sources_consulted": 25,
        "efuns_found": [
          "ADD",
          "GE",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "context": "From FluffOS at line 1299",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1376",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "context": "From FluffOS at line 1383",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1455",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "context": "From FluffOS at line 1462",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "context": "From FluffOS at line 1550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "context": "From FluffOS at line 1643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "context": "From FluffOS at line 1655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "context": "From FluffOS at line 1816",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "context": "From FluffOS at line 1836",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "context": "From FluffOS at line 1877",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "context": "From FluffOS at line 1878",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "context": "From FluffOS at line 1962",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "context": "From FluffOS at line 1982",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "context": "From FluffOS at line 2018",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "context": "From FluffOS at line 2073",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "context": "From FluffOS at line 8",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "context": "From FluffOS at line 11",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "context": "From FluffOS at line 78",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "context": "From FluffOS at line 107",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "context": "From FluffOS at line 191",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "code": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "context": "From FluffOS at line 1",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "context": "From FluffOS at line 50",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "context": "From FluffOS at line 79",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "code": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "context": "From FluffOS at line 17",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 0.5,
      "quality_score": 0.7082572,
      "timestamp": "2026-01-25T17:33:25.121037600+00:00"
    },
    {
      "model_name": "qwen2.5-coder:1.5b",
      "query": "How do I implement a combat system in LPC?",
      "response": "To implement a combat system in LPC, you can follow the steps outlined below, using MudOS/FluffOS patterns as reference sources:\n\n### 1. Follow MudOS/FluffOS Patterns\n\n#### 1.1 Define Combat Entities\n\n- **Player**: Represent characters with attributes like health, mana, and skills.\n- **Monster**: Represent non-player characters with attributes like hit points, attack power, defense, and experience.\n\n#### 1.2 Implement Combat Mechanics\n\n- **Attack**: Define a function to handle attacks between players or monsters.\n- **Defense**: Implement a function to calculate damage based on the attacker's and defender's attributes.\n- **Turn-Based Combat**: Handle turns where each player takes a turn in combat.\n\n#### 1.3 Manage State\n\n- **Health Points**: Keep track of health points for both players and monsters.\n- **Experience Points**: Track experience points for characters to level up.\n- **Inventory**: Implement an inventory system for characters.\n\n### 2. Avoid Redefining Platform APIs\n\n- **Avoid Replacing System Calls**: Use existing system calls like `read()` for input, `write()` for output, and `sleep()` for delays.\n- **Use Existing Functions**: Instead of redefining functions like `strcpy()`, use the standard library functions.\n\n### 3. Keep Outputs Self-contained\n\n- **Include Only Referenced Code**: When generating code, include only what is referenced in retrieved snippets to keep the output self-contained.\n- **Avoid Placeholder TODOs**: Replace placeholder TODOs with actual implementation details.\n\n### 4. For Codegen: Emit Bytecode Opcodes Only\n\n- **Traverse AST Recursively**: Traverse the Abstract Syntax Tree (AST) of the LPC code to emit bytecode opcodes.\n- **Use CALL_METHOD/OP_SUPER_CALL**: Use these opcodes to call methods and access superclass methods.\n\n### 5. For Object/efun Tasks: Use CALL_METHOD/OP_SUPER_CALL, Respect Master Hooks, Avoid Redefinitions\n\n- **Call Methods**: Use `CALL_METHOD` or `OP_SUPER_CALL` to call methods on objects.\n- **Respect Master Hooks**: Ensure that master hooks are called correctly when necessary.\n- **Avoid Redefinitions**: Do not redefine existing functions or structures; instead, use existing ones.\n\n### 6. Return Complete, Compilable C Code with Clear Headers and No Placeholder TODOs\n\n- **Include Header Files**: Include header files for all used libraries and functions to ensure the code is self-contained.\n- **Remove Placeholder TODOs**: Replace placeholder TODOs with actual implementation details.\n- **Use Proper Naming Conventions**: Use meaningful names for variables, functions, and classes.\n\n### Example Code Snippet\n\nHere's a simplified example of how you might implement combat mechanics in LPC:\n\n```lpc\n// Define the Player structure\nstruct player {\n    int health;\n    int mana;\n    int experience;\n};\n\n// Define the Monster structure\nstruct monster {\n    int hit_points;\n    int attack_power;\n    int defense;\n    int experience;\n};\n\n// Function to handle an attack between two players\nvoid attack_player(struct player *attacker, struct player *defender) {\n    // Calculate damage based on attacker's and defender's attributes\n    int damage = attacker->attack_power - defender->defense;\n    \n    // Reduce defender's health\n    defender->health -= damage;\n    \n    // Check if the defender is defeated\n    if (defender->health <= 0) {\n        printf(\"Defender has been defeated!\\n\");\n        // Handle defeat, e.g., award experience points\n    } else {\n        printf(\"Attacker deals %d damage to defender.\\n\", damage);\n    }\n}\n\n// Example usage of the combat system\nvoid main() {\n    struct player player1 = {100, 50, 0};\n    struct monster monster1 = {200, 30, 20, 0};\n\n    attack_player(&player1, &monster1);\n\n    // Additional code to handle turns, inventory management, and other combat-related tasks\n}\n```\n\n### Explanation\n\n- **Player and Monster Structures**: Define the structures for players and monsters with attributes like health, mana, and experience.\n- **Attack Function**: Implement a function `attack_player` that calculates damage based on attacker's and defender's attributes, reduces defender's health, and checks if the defender is defeated.\n- **Main Function**: Example usage of the combat system where two players engage in an attack.\n\nThis example provides a basic framework for implementing combat mechanics in LPC, following MudOS/FluffOS patterns and avoiding redefining platform APIs.",
      "response_time_ms": 14215,
      "tokens_per_second": 55.784184,
      "validation_result": {
        "query": "How do I implement a combat system in LPC?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "relevance_score": 0.55,
            "snippet": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "line_number": 292,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "relevance_score": 0.55,
            "snippet": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "line_number": 550,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "relevance_score": 0.55,
            "snippet": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "line_number": 4,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "relevance_score": 0.55,
            "snippet": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "line_number": 3,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "relevance_score": 0.35000002,
            "snippet": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "line_number": 47,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "line_number": 49,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.7540002,
        "validation_score": 0.828,
        "sources_consulted": 25,
        "efuns_found": [
          "EQ",
          "GE",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 104",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "code": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "context": "From FluffOS at line 292",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "code": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "context": "From FluffOS at line 550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "code": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "context": "From FluffOS at line 4",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "code": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "context": "From FluffOS at line 3",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "code": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "context": "From DGD at line 22",
            "driver": "DGD"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "context": "From Unknown at line 47",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "context": "From Unknown at line 49",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 0.5,
      "quality_score": 0.6919143,
      "timestamp": "2026-01-25T17:33:39.336583100+00:00"
    },
    {
      "model_name": "qwen2.5-coder:1.5b",
      "query": "Show me the correct syntax for query_* functions",
      "response": "Certainly! Below is the correct syntax for `query_*` functions based on MudOS/FluffOS patterns:\n\n### Querying Objects\n\n#### Example: Querying a Player's Name\n```c\n// Assuming 'player' is a valid pointer to an object representing a player\nconst char *name = query_name(player);\n```\n\n#### Example: Querying a Room's Description\n```c\n// Assuming 'room' is a valid pointer to an object representing a room\nconst char *description = query_description(room);\n```\n\n### Querying Players\n\n#### Example: Querying a Player's ID\n```c\n// Assuming 'player' is a valid pointer to an object representing a player\nint playerId = query_player_id(player);\n```\n\n#### Example: Querying a Player's Level\n```c\n// Assuming 'player' is a valid pointer to an object representing a player\nint level = query_level(player);\n```\n\n### Querying Rooms\n\n#### Example: Querying a Room's Exit Count\n```c\n// Assuming 'room' is a valid pointer to an object representing a room\nint exitCount = query_exit_count(room);\n```\n\n### Querying Items\n\n#### Example: Querying an Item's Name\n```c\n// Assuming 'item' is a valid pointer to an object representing an item\nconst char *itemName = query_item_name(item);\n```\n\n#### Example: Querying an Item's Weight\n```c\n// Assuming 'item' is a valid pointer to an object representing an item\nint weight = query_item_weight(item);\n```\n\n### Querying NPCs\n\n#### Example: Querying an NPC's Name\n```c\n// Assuming 'npc' is a valid pointer to an object representing an NPC\nconst char *npcName = query_npc_name(npc);\n```\n\n#### Example: Querying an NPC's Health\n```c\n// Assuming 'npc' is a valid pointer to an object representing an NPC\nint health = query_npc_health(npc);\n```\n\n### Querying Effects\n\n#### Example: Querying an Effect's Name\n```c\n// Assuming 'effect' is a valid pointer to an object representing an effect\nconst char *effectName = query_effect_name(effect);\n```\n\n#### Example: Querying an Effect's Duration\n```c\n// Assuming 'effect' is a valid pointer to an object representing an effect\nint duration = query_effect_duration(effect);\n```\n\n### Querying Conditions\n\n#### Example: Querying a Condition's Name\n```c\n// Assuming 'condition' is a valid pointer to an object representing a condition\nconst char *conditionName = query_condition_name(condition);\n```\n\n#### Example: Querying a Condition's Type\n```c\n// Assuming 'condition' is a valid pointer to an object representing a condition\nint conditionType = query_condition_type(condition);\n```\n\n### Querying Actions\n\n#### Example: Querying an Action's Name\n```c\n// Assuming 'action' is a valid pointer to an object representing an action\nconst char *actionName = query_action_name(action);\n```\n\n#### Example: Querying an Action's Parameters\n```c\n// Assuming 'action' is a valid pointer to an object representing an action\nint numParams = query_num_params(action);\nconst char **params = query_params(action);\n```\n\n### Querying Properties\n\n#### Example: Querying a Property's Name\n```c\n// Assuming 'prop' is a valid pointer to an object representing a property\nconst char *propertyName = query_property_name(prop);\n```\n\n#### Example: Querying a Property's Value\n```c\n// Assuming 'prop' is a valid pointer to an object representing a property\nint value = query_property_value(prop);\n```\n\n### Querying Functions\n\n#### Example: Querying a Function's Name\n```c\n// Assuming 'func' is a valid pointer to an object representing a function\nconst char *funcName = query_function_name(func);\n```\n\n#### Example: Querying a Function's Parameters\n```c\n// Assuming 'func' is a valid pointer to an object representing a function\nint numParams = query_num_params(func);\nconst char **params = query_params(func);\n```\n\n### Querying Mappings\n\n#### Example: Querying a Mapping's Key\n```c\n// Assuming 'mapping' is a valid pointer to an object representing a mapping\nconst char *key = query_mapping_key(mapping, index);\n```\n\n#### Example: Querying a Mapping's Value\n```c\n// Assuming 'mapping' is a valid pointer to an object representing a mapping\nint value = query_mapping_value(mapping, key);\n```\n\n### Querying Arrays\n\n#### Example: Querying an Array's Length\n```c\n// Assuming 'array' is a valid pointer to an object representing an array\nint length = query_array_length(array);\n```\n\n#### Example: Querying an Array's Element\n```c\n// Assuming 'array' is a valid pointer to an object representing an array\nint element = query_array_element(array, index);\n```\n\n### Querying Objects in Lists\n\n#### Example: Querying an Object in a List by Index\n```c\n// Assuming 'list' is a valid pointer to an object representing a list\nconst char *objName = query_list_object(list, index);\n```\n\n### Querying Objects in Maps\n\n#### Example: Querying an Object in a Map by Key\n```c\n// Assuming 'map' is a valid pointer to an object representing a map\nconst char *objName = query_map_object(map, key);\n```\n\n### Querying Objects in Arrays\n\n#### Example: Querying an Object in an Array by Index\n```c\n// Assuming 'array' is a valid pointer to an object representing an array\nconst char *objName = query_array_object(array, index);\n```\n\n### Querying Objects in Mappings\n\n#### Example: Querying an Object in a Mapping by Key\n```c\n// Assuming 'mapping' is a valid pointer to an object representing a mapping\nconst char *objName = query_mapping_object(mapping, key);\n```\n\n### Querying Objects in Lists and Maps\n\n#### Example: Querying an Object in a List or Map by Index\n```c\n// Assuming 'listOrMap' is a valid pointer to an object representing a list or map\nconst char *objName = query_list_or_map_object(listOrMap, index);\n```\n\n### Querying Objects in Arrays and Mappings\n\n#### Example: Querying an Object in an Array or Map by Index\n```c\n// Assuming 'arrayOrMap' is a valid pointer to an object representing an array or map\nconst char *objName = query_array_or_map_object(arrayOrMap, index);\n```\n\n### Querying Objects in Lists and Maps with Specific Conditions\n\n#### Example: Querying an Object in a List or Map by Index with Condition\n```c\n// Assuming 'listOrMap' is a valid pointer to an object representing a list or map\nconst char *objName = query_list_or_map_object_with_condition(listOrMap, index, condition);\n```\n\n### Querying Objects in Lists and Maps with Specific Conditions and Parameters\n\n#### Example: Querying an Object in a List or Map by Index with Condition and Parameters\n```c\n// Assuming 'listOrMap' is a valid pointer to an object representing a list or map\nconst char *objName = query_list_or_map_object_with_condition_and_params(listOrMap, index, condition, params);\n```\n\n### Querying Objects in Lists and Maps with Specific Conditions and Parameters and Return Type\n\n#### Example: Querying an Object in a List or Map by Index with Condition and Parameters and Return Type\n```c\n// Assuming 'listOrMap' is a valid pointer to an object representing a list or map\nconst char *objName = query_list_or_map_object_with_condition_and_params_and_return_type(listOrMap, index, condition, params, returnType);\n```\n\n### Querying Objects in Lists and Maps with Specific Conditions and Parameters and Return Type and Error Handling\n\n#### Example: Querying an Object in a List or Map by Index with Condition and Parameters and Return Type and Error Handling\n```c\n// Assuming 'listOrMap' is a valid pointer to an object representing a list or map\nconst char *objName = query_list_or_map_object_with_condition_and_params_and_return_type_and_error_handling(listOrMap, index, condition, params, returnType, errorHandling);\n```\n\n### Querying Objects in Lists and Maps with Specific Conditions and Parameters and Return Type and Error Handling and Logging\n\n#### Example: Querying an Object in a List or Map by Index with Condition and Parameters and Return Type and Error Handling and Logging\n```c\n// Assuming 'listOrMap' is a valid pointer to an object representing a list or map\nconst char *objName = query_list_or_map_object_with_condition_and_params_and_return_type_and_error_handling_and_logging(listOrMap, index, condition, params, returnType, errorHandling, logging);\n```\n\n### Querying Objects in Lists and Maps with Specific Conditions and Parameters and Return Type and Error Handling and Logging and Debugging\n\n#### Example: Querying an Object in a List or Map by Index with Condition and Parameters and Return Type and Error Handling and Logging and Debugging\n```c\n// Assuming 'listOrMap' is a valid pointer to an object representing a list or map\nconst char *objName = query_list_or_map_object_with_condition_and_params_and_return_type_and_error_handling_and_logging_and_debugging(listOrMap, index, condition, params, returnType, errorHandling, logging, debugging);\n```\n\n### Querying Objects in Lists and Maps with Specific Conditions and Parameters and Return Type and Error Handling and Logging and Debugging and Profiling\n\n#### Example: Querying an Object in a List or Map by Index with Condition and Parameters and Return Type and Error Handling and Logging and Debugging and Profiling\n```c\n// Assuming '",
      "response_time_ms": 12688,
      "tokens_per_second": 134.11174,
      "validation_result": {
        "query": "Show me the correct syntax for query_* functions",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "line_number": 4636,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "relevance_score": 0.57857144,
            "snippet": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "line_number": 1105,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "relevance_score": 0.57857144,
            "snippet": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "line_number": 540,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "line_number": 2187,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "relevance_score": 0.57857144,
            "snippet": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "line_number": 71,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "relevance_score": 0.57857144,
            "snippet": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "line_number": 145,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "relevance_score": 0.57857144,
            "snippet": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "line_number": 27,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "line_number": 31,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "line_number": 35,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "line_number": 59,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "line_number": 25,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "relevance_score": 0.57857144,
            "snippet": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "line_number": 1153,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "relevance_score": 0.57857144,
            "snippet": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "line_number": 280,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "line_number": 109,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "line_number": 57,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "line_number": 23,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "relevance_score": 0.57857144,
            "snippet": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "line_number": 18,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "line_number": 17,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.62657136,
        "validation_score": 0.39600003,
        "sources_consulted": 25,
        "efuns_found": [
          "LE",
          "LOG",
          "NE",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "context": "From FluffOS at line 4636",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "code": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "context": "From FluffOS at line 1105",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "code": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "context": "From FluffOS at line 540",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "code": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "context": "From FluffOS at line 2187",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "code": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "context": "From FluffOS at line 71",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "code": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "context": "From Unknown at line 145",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "code": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "context": "From Unknown at line 1",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 31",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "code": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "context": "From Unknown at line 59",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "code": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "context": "From Unknown at line 25",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "code": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "context": "From Unknown at line 1153",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "code": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "context": "From Unknown at line 280",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "code": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "context": "From Unknown at line 57",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "code": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "context": "From Unknown at line 23",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "code": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "code": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "context": "From Unknown at line 22",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "code": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "context": "From Unknown at line 18",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "code": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "context": "From Unknown at line 17",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 1.0,
      "quality_score": 0.6536857,
      "timestamp": "2026-01-25T17:33:52.025323+00:00"
    },
    {
      "model_name": "qwen2.5-coder:1.5b",
      "query": "What's the difference between call_other() and call_out()?",
      "response": "```c\n// Define a function to call another efun with parameters\nvoid call_other(const char *efun_name, ...) {\n    // Prepare the arguments for the efun call\n    va_list args;\n    va_start(args, efun_name);\n\n    // Call the efun using the provided name and arguments\n    int result = call_efun(efun_name, args);\n\n    // Clean up the argument list\n    va_end(args);\n}\n\n// Define a function to call an external C function from LPC\nvoid call_out(void (*function)(void), void *arg) {\n    // Prepare the arguments for the efun call\n    va_list args;\n    va_start(args, function);\n\n    // Call the efun using the provided name and arguments\n    int result = call_efun(\"call_out\", args);\n\n    // Clean up the argument list\n    va_end(args);\n}\n```\n\nIn this solution, `call_other()` is designed to call another efun with a variable number of arguments. It uses `va_list` to handle the variable arguments and `call_efun()` to invoke the efun with the provided name and arguments.\n\nSimilarly, `call_out()` is designed to call an external C function from LPC. It also uses `va_list` to handle the variable arguments and `call_efun()` to invoke the efun with the provided name and arguments.",
      "response_time_ms": 20159,
      "tokens_per_second": 11.284946,
      "validation_result": {
        "query": "What's the difference between call_other() and call_out()?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "relevance_score": 0.72142863,
            "snippet": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "line_number": 10,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "line_number": 85,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "line_number": 93,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "line_number": 102,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "line_number": 157,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "line_number": 230,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "line_number": 246,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.9048573,
        "validation_score": 0.804,
        "sources_consulted": 25,
        "efuns_found": [
          "CALL_OTHER",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "code": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "code": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "context": "From FluffOS at line 10",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From MudOS at line 36",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From MudOS at line 35",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From FluffOS at line 109",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "context": "From FluffOS at line 85",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "context": "From FluffOS at line 93",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "context": "From FluffOS at line 157",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "context": "From FluffOS at line 230",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "context": "From FluffOS at line 246",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 0.5,
      "quality_score": 0.7986001,
      "timestamp": "2026-01-25T17:34:12.184949200+00:00"
    },
    {
      "model_name": "qwen2.5-coder:1.5b",
      "query": "Generate a basic room inherit for the std/room.c",
      "response": "```c\ninherit \"/std/room\";\n```\n\nThis line of code inherits from the standard room template provided by the MudOS library, allowing you to define the basic structure and functions that all rooms in your game will have. You can then add specific descriptions, exits, items, sounds, smells, tastes, and more as needed for your game's world.",
      "response_time_ms": 12880,
      "tokens_per_second": 5.5511236,
      "validation_result": {
        "query": "Generate a basic room inherit for the std/room.c",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "relevance_score": 0.72142863,
            "snippet": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "line_number": 0,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "line_number": 222,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "relevance_score": 0.57857144,
            "snippet": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "line_number": 2555,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.57857144,
            "snippet": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "line_number": 2384,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "line_number": 2945,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 655,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 819,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "relevance_score": 0.57857144,
            "snippet": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "line_number": 643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "relevance_score": 0.57857144,
            "snippet": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "line_number": 16,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "line_number": 202,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "line_number": 357,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "line_number": 54,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "line_number": 89,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "relevance_score": 0.57857144,
            "snippet": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "line_number": 27,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "relevance_score": 0.57857144,
            "snippet": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "line_number": 32,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "line_number": 325,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "line_number": 331,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "line_number": 338,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "line_number": 9,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "relevance_score": 0.57857144,
            "snippet": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "line_number": 29,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "relevance_score": 0.57857144,
            "snippet": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "line_number": 88,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "line_number": 101,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "line_number": 108,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "line_number": 120,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.6622856,
        "validation_score": 0.46800002,
        "sources_consulted": 25,
        "efuns_found": [
          "GE",
          "LE",
          "MOD",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "code": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "context": "From FluffOS at line 0",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "context": "From FluffOS at line 222",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "code": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "context": "From FluffOS at line 2555",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "context": "From FluffOS at line 2384",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "context": "From FluffOS at line 2945",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 819",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "code": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "context": "From FluffOS at line 643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "code": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "context": "From FluffOS at line 16",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "context": "From FluffOS at line 202",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "context": "From FluffOS at line 357",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "code": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "context": "From Unknown at line 54",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "code": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "context": "From Unknown at line 89",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "code": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "code": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "context": "From Unknown at line 32",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "context": "From Unknown at line 325",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "context": "From Unknown at line 331",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "context": "From Unknown at line 338",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "code": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "code": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "context": "From Unknown at line 29",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "code": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "code": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "context": "From Unknown at line 88",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "context": "From Unknown at line 101",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "context": "From Unknown at line 108",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "context": "From Unknown at line 120",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 0.5,
      "quality_score": 0.63725716,
      "timestamp": "2026-01-25T17:34:25.065247900+00:00"
    },
    {
      "model_name": "qwen2.5-coder:1.5b",
      "query": "How does the LPC object inheritance system work?",
      "response": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define basic types and structures for LPC objects\ntypedef struct {\n    char *name;\n    int refcount;\n} Object;\n\ntypedef struct {\n    Object *parent;\n    Object **children;\n    int num_children;\n} ObjectTree;\n\n// Function prototypes\nObject *create_object(const char *name);\nvoid delete_object(Object *obj);\nvoid add_child(Object *parent, Object *child);\nvoid remove_child(Object *parent, Object *child);\nint is_descendant(Object *child, Object *ancestor);\n\nint main() {\n    // Create objects\n    Object *root = create_object(\"Root\");\n    Object *child1 = create_object(\"Child1\");\n    Object *child2 = create_object(\"Child2\");\n\n    // Add children to the root object\n    add_child(root, child1);\n    add_child(root, child2);\n\n    // Check if a child is a descendant of another\n    printf(\"Is Child1 a descendant of Root? %d\\n\", is_descendant(child1, root));\n\n    // Delete objects\n    delete_object(child1);\n    delete_object(child2);\n    delete_object(root);\n\n    return 0;\n}\n\n// Function to create an object\nObject *create_object(const char *name) {\n    Object *obj = (Object *)malloc(sizeof(Object));\n    obj->name = strdup(name);\n    obj->refcount = 1;\n    obj->parent = NULL;\n    obj->children = NULL;\n    obj->num_children = 0;\n    return obj;\n}\n\n// Function to delete an object\nvoid delete_object(Object *obj) {\n    if (obj == NULL) {\n        return;\n    }\n\n    // Decrement reference count and free memory if necessary\n    obj->refcount--;\n    if (obj->refcount == 0) {\n        free(obj->name);\n        free(obj);\n    }\n}\n\n// Function to add a child to an object\nvoid add_child(Object *parent, Object *child) {\n    if (parent == NULL || child == NULL) {\n        return;\n    }\n\n    // Create children array if it doesn't exist\n    if (parent->children == NULL) {\n        parent->children = (Object **)malloc(sizeof(Object *));\n        parent->num_children = 0;\n    }\n\n    // Add the new child to the array\n    parent->children[parent->num_children++] = child;\n}\n\n// Function to remove a child from an object\nvoid remove_child(Object *parent, Object *child) {\n    if (parent == NULL || child == NULL) {\n        return;\n    }\n\n    // Find and remove the child from the array\n    for (int i = 0; i < parent->num_children; i++) {\n        if (parent->children[i] == child) {\n            free(parent->children[i]);\n            parent->children[i] = parent->children[--parent->num_children];\n            return;\n        }\n    }\n}\n\n// Function to check if a child is a descendant of another\nint is_descendant(Object *child, Object *ancestor) {\n    if (child == NULL || ancestor == NULL) {\n        return 0;\n    }\n\n    // Traverse the object tree from the child up to the root\n    while (child != ancestor && child->parent != NULL) {\n        child = child->parent;\n    }\n\n    return child == ancestor;\n}\n```\n\nThis C code defines a basic object system for LPC objects, including creation, deletion, adding and removing children, and checking if one object is a descendant of another. The `create_object` function allocates memory for a new object and initializes its fields. The `delete_object` function decrements the reference count and frees the memory if necessary. The `add_child` and `remove_child` functions manage the array of children for each object. The `is_descendant` function traverses the object tree to determine if one object is a descendant of another.",
      "response_time_ms": 15618,
      "tokens_per_second": 37.373398,
      "validation_result": {
        "query": "How does the LPC object inheritance system work?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "line_number": 1299,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1376,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "line_number": 1383,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1455,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "line_number": 1462,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "line_number": 1550,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "line_number": 1643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "line_number": 1655,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "line_number": 1816,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "line_number": 1836,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "line_number": 1877,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "line_number": 1878,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "line_number": 1962,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "line_number": 1982,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "line_number": 2018,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "line_number": 2073,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "line_number": 8,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "line_number": 11,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "line_number": 78,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "line_number": 107,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "line_number": 191,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "relevance_score": 0.6,
            "snippet": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "line_number": 50,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "line_number": 79,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "relevance_score": 0.6,
            "snippet": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "line_number": 17,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.61800015,
        "validation_score": 0.33600003,
        "sources_consulted": 25,
        "efuns_found": [
          "ADD",
          "GE",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "context": "From FluffOS at line 1299",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1376",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "context": "From FluffOS at line 1383",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1455",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "context": "From FluffOS at line 1462",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "context": "From FluffOS at line 1550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "context": "From FluffOS at line 1643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "context": "From FluffOS at line 1655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "context": "From FluffOS at line 1816",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "context": "From FluffOS at line 1836",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "context": "From FluffOS at line 1877",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "context": "From FluffOS at line 1878",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "context": "From FluffOS at line 1962",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "context": "From FluffOS at line 1982",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "context": "From FluffOS at line 2018",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "context": "From FluffOS at line 2073",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "context": "From FluffOS at line 8",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "context": "From FluffOS at line 11",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "context": "From FluffOS at line 78",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "context": "From FluffOS at line 107",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "context": "From FluffOS at line 191",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "code": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "context": "From FluffOS at line 1",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "context": "From FluffOS at line 50",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "context": "From FluffOS at line 79",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "code": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "context": "From FluffOS at line 17",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 0.25,
      "quality_score": 0.65111434,
      "timestamp": "2026-01-25T17:34:40.683347800+00:00"
    },
    {
      "model_name": "llama2:latest",
      "query": "How do I implement a combat system in LPC?",
      "response": "I'm just an AI, I don't have personal preferences or opinions, but I can provide you with some general tips on how to approach your task of implementing a combat system in LPC.\n\n1. Familiarize yourself with the LPC reference materials: The first step is to familiarize yourself with the LPC reference materials, such as the LPC manual and the MudOS documentation. This will give you a good understanding of the language and the available features that you can use to implement your combat system.\n2. Start with a simple implementation: Don't try to implement a complex combat system right away. Start with a simple implementation, such as a basic attack and defend mechanism. This will allow you to get a feel for how the language works and how to structure your code.\n3. Use CALL_METHOD and OP_SUPER_CALL: LPC provides two mechanisms for calling functions: CALL_METHOD and OP_SUPER_CALL. These can be used to call functions in a structured way, which is useful for implementing a combat system.\n4. Respect master hooks: Master hooks are special functions that can be used to intercept and modify the behavior of other functions. When implementing a combat system, it's important to respect these hooks, as they can be used to modify the behavior of your code.\n5. Use clear headers: When implementing a combat system, it's important to use clear headers that describe the purpose of each function. This will make your code easier to read and understand, and will also help you to avoid errors and bugs.\n6. Avoid redefinitions: When implementing a combat system, it's important to avoid redefinitions of existing functions. Instead, use the CALL_METHOD and OP_SUPER_CALL mechanisms to call these functions in a structured way.\n7. Test your code: Once you have implemented your combat system, it's important to test it thoroughly to ensure that it works as expected. Use the LPC test suite to test your code, and make sure that it passes all of the required tests.\n\nBy following these tips, you should be able to implement a basic combat system in LPC. Of course, this is just the starting point, and you can always add more features and complexity to your combat system as needed.",
      "response_time_ms": 13942,
      "tokens_per_second": 34.31249,
      "validation_result": {
        "query": "How do I implement a combat system in LPC?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "relevance_score": 0.55,
            "snippet": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "line_number": 292,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "relevance_score": 0.55,
            "snippet": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "line_number": 550,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "relevance_score": 0.55,
            "snippet": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "line_number": 4,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "relevance_score": 0.55,
            "snippet": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "line_number": 3,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "relevance_score": 0.35000002,
            "snippet": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "line_number": 47,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "line_number": 49,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.7540002,
        "validation_score": 0.828,
        "sources_consulted": 25,
        "efuns_found": [
          "EQ",
          "GE",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 104",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "code": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "context": "From FluffOS at line 292",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "code": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "context": "From FluffOS at line 550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "code": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "context": "From FluffOS at line 4",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "code": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "context": "From FluffOS at line 3",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "code": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "context": "From DGD at line 22",
            "driver": "DGD"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "context": "From Unknown at line 47",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "context": "From Unknown at line 49",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 0.25,
      "quality_score": 0.6633429,
      "timestamp": "2026-01-25T17:34:54.625831900+00:00"
    },
    {
      "model_name": "llama2:latest",
      "query": "Show me the correct syntax for query_* functions",
      "response": "\nAbout 37% of the text appears to be related to programming or software development, specifically in the context of implementing efun (engine-level functions) in a LPC (Little Programming Language for Computers) environment. The remaining text appears to be related to reference materials and guides for using various archives and tools in the development process.\n\nThe most relevant phrases or keywords in the text include:\n\n* Efun implementation\n* LPC environment\n* Driver design\n* Mudlib structure\n* Object layouts\n* VM and object management\n* Command execution\n* Codegen\n* Compilable C code\n* Header files\n* Tool usage guides\n\nBased on the content of the text, it appears that the user is seeking guidance on how to implement efun functions in a LPC environment, specifically related to driver design and mudlib structure. The user may also be interested in learning about best practices for implementing code generation and object management in this context.",
      "response_time_ms": 7574,
      "tokens_per_second": 26.42936,
      "validation_result": {
        "query": "Show me the correct syntax for query_* functions",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "line_number": 4636,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "relevance_score": 0.57857144,
            "snippet": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "line_number": 1105,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "relevance_score": 0.57857144,
            "snippet": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "line_number": 540,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "line_number": 2187,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "relevance_score": 0.57857144,
            "snippet": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "line_number": 71,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "relevance_score": 0.57857144,
            "snippet": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "line_number": 145,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "relevance_score": 0.57857144,
            "snippet": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "line_number": 27,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "line_number": 31,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "line_number": 35,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "line_number": 59,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "line_number": 25,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "relevance_score": 0.57857144,
            "snippet": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "line_number": 1153,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "relevance_score": 0.57857144,
            "snippet": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "line_number": 280,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "line_number": 109,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "line_number": 57,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "line_number": 23,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "relevance_score": 0.57857144,
            "snippet": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "line_number": 18,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "line_number": 17,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.62657136,
        "validation_score": 0.39600003,
        "sources_consulted": 25,
        "efuns_found": [
          "LE",
          "LOG",
          "NE",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "context": "From FluffOS at line 4636",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "code": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "context": "From FluffOS at line 1105",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "code": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "context": "From FluffOS at line 540",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "code": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "context": "From FluffOS at line 2187",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "code": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "context": "From FluffOS at line 71",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "code": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "context": "From Unknown at line 145",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "code": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "context": "From Unknown at line 1",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 31",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "code": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "context": "From Unknown at line 59",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "code": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "context": "From Unknown at line 25",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "code": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "context": "From Unknown at line 1153",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "code": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "context": "From Unknown at line 280",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "code": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "context": "From Unknown at line 57",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "code": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "context": "From Unknown at line 23",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "code": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "code": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "context": "From Unknown at line 22",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "code": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "context": "From Unknown at line 18",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "code": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "context": "From Unknown at line 17",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 0.33333334,
      "quality_score": 0.5151143,
      "timestamp": "2026-01-25T17:35:02.200769900+00:00"
    },
    {
      "model_name": "llama2:latest",
      "query": "What's the difference between call_other() and call_out()?",
      "response": "Here is an example of how you could implement the LPC MUD driver in C, following the patterns and structures described in the documentation:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"lpc-driver.h\"\n\n// Lexer/Parser\ntypedef struct {\n    int token_type;\n    const char *text;\n} token_t;\n\ntypedef struct {\n    token_t tok[MAX_TOKENS];\n    size_t num_tokens;\n} lexer_state_t;\n\nvoid lexer_init(lexer_state_t *ls) {\n    ls->num_tokens = 0;\n}\n\ntoken_t lexer_get_token(lexer_state_t *ls) {\n    if (ls->num_tokens == MAX_TOKENS) {\n        // Handle overflow\n    } else {\n        token_t token = {\n            .token_type = TOK_UNKNOWN,\n            .text = NULL,\n        };\n        ls->num_tokens++;\n        return token;\n    }\n}\n\n// Compiler/Bytecode\ntypedef struct {\n    lpc_program_t *program;\n    size_t program_size;\n} bytecode_state_t;\n\nvoid compiler_init(bytecode_state_t *bs) {\n    bs->program = NULL;\n    bs->program_size = 0;\n}\n\nvoid compiler_translate(lpc_program_t *program, size_t program_size) {\n    // Translate LPC code to bytecode\n}\n\nvoid bytecode_run(bytecode_state_t *bs) {\n    // Run the compiled bytecode\n}\n\n// Virtual Machine\ntypedef struct {\n    lpc_program_t *program;\n    size_t program_size;\n    int pc;\n    int sp;\n} vm_state_t;\n\nvoid vm_init(vm_state_t *vs) {\n    vs->pc = 0;\n    vs->sp = 0;\n}\n\nvoid vm_step(vm_state_t *vs) {\n    // Execute one instruction\n}\n\n// Object Management\ntypedef struct {\n    lpc_object_t *object;\n    size_t object_size;\n} obj_state_t;\n\nvoid obj_init(obj_state_t *os) {\n    os->object = NULL;\n    os->object_size = 0;\n}\n\nvoid obj_unload(obj_state_t *os) {\n    // Unload the object from memory\n}\n\n// Efuns\ntypedef struct {\n    lpc_efun_t *efun;\n    size_t efun_size;\n} efun_state_t;\n\nvoid efun_init(efun_state_t *es) {\n    es->efun = NULL;\n    es->efun_size = 0;\n}\n\nvoid efun_run(efun_state_t *es) {\n    // Run the registered efun\n}\n\n// Driver API\ntypedef struct {\n    lpc_driver_t *driver;\n} driver_state_t;\n\nvoid driver_init(driver_state_t *ds) {\n    ds->driver = NULL;\n}\n\nvoid driver_run(driver_state_t *ds) {\n    // Run the LPC MUD driver\n}\n```\nNote that this is just an example implementation, and you may need to modify it based on your specific use case and requirements. Additionally, this code does not include any error handling or debugging features, so you will likely want to add those in as well.",
      "response_time_ms": 29941,
      "tokens_per_second": 13.720207,
      "validation_result": {
        "query": "What's the difference between call_other() and call_out()?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "relevance_score": 0.72142863,
            "snippet": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "line_number": 10,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "line_number": 85,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "line_number": 93,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "line_number": 102,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "line_number": 157,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "line_number": 230,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "line_number": 246,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.9048573,
        "validation_score": 0.804,
        "sources_consulted": 25,
        "efuns_found": [
          "CALL_OTHER",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "code": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "code": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "context": "From FluffOS at line 10",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From MudOS at line 36",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From MudOS at line 35",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From FluffOS at line 109",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "context": "From FluffOS at line 85",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "context": "From FluffOS at line 93",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "context": "From FluffOS at line 157",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "context": "From FluffOS at line 230",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "context": "From FluffOS at line 246",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 0.25,
      "quality_score": 0.7657429,
      "timestamp": "2026-01-25T17:35:32.142041100+00:00"
    },
    {
      "model_name": "llama2:latest",
      "query": "Generate a basic room inherit for the std/room.c",
      "response": "Here is a basic room inheritance for `std/room.c`:\n```\n// Inherit from standard room class\ninherit Room;\n\nvoid setup() {\n    // Set up the room's properties and contents\n    set_short(\"Workroom\");\n    set_long(\"You find yourself in a small, cluttered workroom.\");\n    add_furniture(\"desk\", \"a dusty old desk\");\n    add_furniture(\"chair\", \"an old, worn-out chair\");\n    add_lighting(\"lamp\", \"a small lamp on the desk\");\n}\n```\nThis will create a basic room with a short description, a furnished desk and chair, and a single light source (a lamp on the desk). You can modify this inheritance to add more furniture, change the room's properties and contents, or add additional features as needed.",
      "response_time_ms": 16189,
      "tokens_per_second": 8.190481,
      "validation_result": {
        "query": "Generate a basic room inherit for the std/room.c",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "relevance_score": 0.72142863,
            "snippet": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "line_number": 0,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "line_number": 222,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "relevance_score": 0.57857144,
            "snippet": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "line_number": 2555,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.57857144,
            "snippet": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "line_number": 2384,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "line_number": 2945,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 655,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 819,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "relevance_score": 0.57857144,
            "snippet": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "line_number": 643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "relevance_score": 0.57857144,
            "snippet": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "line_number": 16,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "line_number": 202,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "line_number": 357,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "line_number": 54,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "line_number": 89,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "relevance_score": 0.57857144,
            "snippet": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "line_number": 27,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "relevance_score": 0.57857144,
            "snippet": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "line_number": 32,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "line_number": 325,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "line_number": 331,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "line_number": 338,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "line_number": 9,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "relevance_score": 0.57857144,
            "snippet": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "line_number": 29,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "relevance_score": 0.57857144,
            "snippet": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "line_number": 88,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "line_number": 101,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "line_number": 108,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "line_number": 120,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.6622856,
        "validation_score": 0.46800002,
        "sources_consulted": 25,
        "efuns_found": [
          "GE",
          "LE",
          "MOD",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "code": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "context": "From FluffOS at line 0",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "context": "From FluffOS at line 222",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "code": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "context": "From FluffOS at line 2555",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "context": "From FluffOS at line 2384",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "context": "From FluffOS at line 2945",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 819",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "code": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "context": "From FluffOS at line 643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "code": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "context": "From FluffOS at line 16",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "context": "From FluffOS at line 202",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "context": "From FluffOS at line 357",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "code": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "context": "From Unknown at line 54",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "code": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "context": "From Unknown at line 89",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "code": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "code": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "context": "From Unknown at line 32",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "context": "From Unknown at line 325",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "context": "From Unknown at line 331",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "context": "From Unknown at line 338",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "code": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "code": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "context": "From Unknown at line 29",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "code": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "code": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "context": "From Unknown at line 88",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "context": "From Unknown at line 101",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "context": "From Unknown at line 108",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "context": "From Unknown at line 120",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 1.0,
      "quality_score": 0.7258286,
      "timestamp": "2026-01-25T17:35:48.331589+00:00"
    },
    {
      "model_name": "llama2:latest",
      "query": "How does the LPC object inheritance system work?",
      "response": "Sure, here's an example of how the LPC object inheritance system could be implemented in C, following the patterns shown above:\n```c\n#include <stdio.h>\n#include <string.h>\n#include \"lpc.h\"\n\n// Inheritance tree node struct\ntypedef struct {\n    void *data; // Object data\n    struct lpc_object_node *parent; // Parent node in the inheritance tree\n} lpc_object_node_t;\n\n// LPC object inheritance system\nvoid lpc_inherit_object(lpc_object_t *obj, const char *name, ...);\nvoid lpc_inherit_objects(lpc_object_t *obj, const char *name, ...);\n\n// Object creation and inheritance\nlpc_object_t *lpc_create_object(const char *name, ...) {\n    // Allocate memory for object data and inheritance tree node\n    lpc_object_t *obj = calloc(1, sizeof(lpc_object_t));\n    obj->data = calloc(1, sizeof(void *));\n    obj->inheritance_tree = calloc(1, sizeof(lpc_object_node_t));\n\n    // Inherit properties from parent object (if any)\n    if (obj->parent) {\n        lpc_inherit_objects(obj, obj->parent);\n    }\n\n    return obj;\n}\n\n// Object destruction and cleanup\nvoid lpc_destroy_object(lpc_object_t *obj) {\n    // Free object data and inheritance tree node\n    free(obj->data);\n    free(obj->inheritance_tree);\n\n    // Unlink object from parent and siblings in inheritance tree\n    obj->parent = NULL;\n    obj->siblings = NULL;\n}\n\n// Inheritance tree traversal and property resolution\nvoid lpc_traverse_object_tree(lpc_object_t *obj, void (*callback)(const char *name, void *data), ...) {\n    // Traverse inheritance tree from object to root\n    lpc_object_node_t *node = obj->inheritance_tree;\n    while (node) {\n        callback(node->name, node->data);\n        node = node->parent;\n    }\n}\n\n// Property resolution and inheritance\nvoid lpc_resolve_property(lpc_object_t *obj, const char *name) {\n    // Traverse inheritance tree to find property value\n    lpc_traverse_object_tree(obj, NULL, name);\n}\n```\nIn this example, the `lpc_inherit_object` function takes a name and optional arguments, and creates a new object with inherited properties from its parent object. The `lpc_inherit_objects` function is similar, but recursively inherits properties from all parent objects. The `lpc_destroy_object` function frees the object's data and inheritance tree node when it's no longer needed. The `lpc_traverse_object_tree` function traverses the inheritance tree from an object to its root, calling a callback function for each property name found. Finally, the `lpc_resolve_property` function resolves a property value by traversing the inheritance tree from the object to its root.\n\nNote that this is just one possible implementation of the LPC object inheritance system in C, and there are many variations and optimizations possible depending on the specific requirements and constraints of your application.",
      "response_time_ms": 22313,
      "tokens_per_second": 20.56557,
      "validation_result": {
        "query": "How does the LPC object inheritance system work?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "line_number": 1299,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1376,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "line_number": 1383,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1455,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "line_number": 1462,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "line_number": 1550,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "line_number": 1643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "line_number": 1655,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "line_number": 1816,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "line_number": 1836,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "line_number": 1877,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "line_number": 1878,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "line_number": 1962,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "line_number": 1982,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "line_number": 2018,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "line_number": 2073,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "line_number": 8,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "line_number": 11,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "line_number": 78,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "line_number": 107,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "line_number": 191,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "relevance_score": 0.6,
            "snippet": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "line_number": 50,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "line_number": 79,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "relevance_score": 0.6,
            "snippet": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "line_number": 17,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.61800015,
        "validation_score": 0.33600003,
        "sources_consulted": 25,
        "efuns_found": [
          "ADD",
          "GE",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "context": "From FluffOS at line 1299",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1376",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "context": "From FluffOS at line 1383",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1455",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "context": "From FluffOS at line 1462",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "context": "From FluffOS at line 1550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "context": "From FluffOS at line 1643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "context": "From FluffOS at line 1655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "context": "From FluffOS at line 1816",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "context": "From FluffOS at line 1836",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "context": "From FluffOS at line 1877",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "context": "From FluffOS at line 1878",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "context": "From FluffOS at line 1962",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "context": "From FluffOS at line 1982",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "context": "From FluffOS at line 2018",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "context": "From FluffOS at line 2073",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "context": "From FluffOS at line 8",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "context": "From FluffOS at line 11",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "context": "From FluffOS at line 78",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "context": "From FluffOS at line 107",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "context": "From FluffOS at line 191",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "code": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "context": "From FluffOS at line 1",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "context": "From FluffOS at line 50",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "context": "From FluffOS at line 79",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "code": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "context": "From FluffOS at line 17",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 0.5,
      "quality_score": 0.7082572,
      "timestamp": "2026-01-25T17:36:10.645617400+00:00"
    },
    {
      "model_name": "qwen2.5-coder:7b",
      "query": "How do I implement a combat system in LPC?",
      "response": "To implement a basic combat system in LPC, you can follow these steps:\n\n1. **Define Combat Mechanics**: Decide on the core mechanics of your combat system. For simplicity, let's assume each combatant has health points (HP), attack power, and defense.\n\n2. **Create Combatant Objects**: Define an object that represents a combatant. This object will have properties for HP, attack, and defense.\n\n3. **Implement Combat Functions**: Create functions to handle the logic of attacking and defending.\n\n4. **Integrate with Existing System**: Ensure that your combat system integrates well with existing LPC objects and efuns.\n\nHere's a basic example of how you might implement this:\n\n### Combatant Object (`/std/combatant.c`)\n\n```lpc\ninherit \"/std/object\";\n\nint hp;\nint attack;\nint defense;\n\nvoid create() {\n    ::create();\n    set_name(\"combatant\");\n    set_short(\"a combatant\");\n    set_long(\"This is a generic combatant object.\");\n    \n    hp = 100; // Default HP\n    attack = 20; // Default attack power\n    defense = 10; // Default defense power\n}\n\nint get_hp() {\n    return hp;\n}\n\nvoid set_hp(int new_hp) {\n    if (new_hp < 0) new_hp = 0;\n    hp = new_hp;\n}\n\nint do_attack(object target) {\n    int damage = attack - target->query_defense();\n    if (damage > 0) {\n        target->set_hp(target->get_hp() - damage);\n        write(\"You hit \" + target->query_name() + \" for \" + damage + \" HP.\\n\");\n        return 1;\n    } else {\n        write(\"Your attack misses!\\n\");\n        return 0;\n    }\n}\n\nint query_defense() {\n    return defense;\n}\n```\n\n### Combat Example (`/lib/combat_example.c`)\n\n```lpc\ninherit \"/std/object\";\n\nvoid create() {\n    ::create();\n    set_name(\"combat example\");\n    set_short(\"a combat example\");\n    set_long(\"This is an example of a combat scenario.\");\n    \n    object player1 = clone_object(\"/std/combatant\");\n    object player2 = clone_object(\"/std/combatant\");\n    \n    player1->set_attack(30);\n    player1->set_defense(15);\n    \n    player2->set_attack(25);\n    player2->set_defense(10);\n    \n    write(\"Combat begins!\\n\");\n    while (player1->get_hp() > 0 && player2->get_hp() > 0) {\n        if (random(2)) {\n            player1->do_attack(player2);\n        } else {\n            player2->do_attack(player1);\n        }\n    }\n    \n    if (player1->get_hp() > 0) {\n        write(\"Player 1 wins!\\n\");\n    } else {\n        write(\"Player 2 wins!\\n\");\n    }\n}\n```\n\n### Explanation\n\n1. **Combatant Object (`/std/combatant.c`)**:\n   - This object represents a combatant with properties for HP, attack, and defense.\n   - It includes methods to get and set HP, do an attack on another combatant, and query the defense value.\n\n2. **Combat Example (`/lib/combat_example.c`)**:\n   - This example creates two combatant objects and simulates a simple combat scenario where they take turns attacking each other until one of them is defeated.\n   - It outputs the results of each attack to the player.\n\nThis basic framework can be expanded with more features such as different types of attacks, spells, armor, and more complex AI for NPCs.",
      "response_time_ms": 18303,
      "tokens_per_second": 28.339394,
      "validation_result": {
        "query": "How do I implement a combat system in LPC?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "relevance_score": 0.55,
            "snippet": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "line_number": 292,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "relevance_score": 0.55,
            "snippet": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "line_number": 550,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "relevance_score": 0.55,
            "snippet": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "line_number": 4,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "relevance_score": 0.55,
            "snippet": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "line_number": 3,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 102,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 104,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "line_number": 96,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "relevance_score": 0.55,
            "snippet": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "line_number": 98,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "relevance_score": 0.35000002,
            "snippet": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "line_number": 47,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "relevance_score": 0.35000002,
            "snippet": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "line_number": 49,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.7540002,
        "validation_score": 0.828,
        "sources_consulted": 25,
        "efuns_found": [
          "EQ",
          "GE",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 104",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\dankequip\\stats.c",
            "code": "    return i-10+\"\";\n  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n\n/* Add of Sojans code to get the new combat system working */\n\nvoid set_extra_bonus(string type, int exbon)\n{\n  switch (type)\n  {\n    case \"attack\" :",
            "context": "From FluffOS at line 292",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\living\\stats.c",
            "code": "  if (i==28)\n    return \"18/00\";\n  return \"18/\"+(i-18)+\"0\";\n}\n*/\n\n/* Add of Sojans code to get the new combat system working */\n/* This will be changed, only one source of bonuses please..\n * Espesially for AC.. */\n/* No string bonus, use ints and query directly on the attack / defend bonus */\n\nvoid set_magical(int mnm)\n{",
            "context": "From FluffOS at line 550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\weapon_logic.c",
            "code": "\n/*\n   New weapon Logic by Sojan.  Designed to implement weapons in a such a way\n   to make combat/weapons design as close as possible to the way it is\n   implemented in the Rolemaster FRPG system.  Hopefully it should be\n   easily modifiable to any other FRPG system as well.\n\n   * Baldrick here, tuned it so that it works witth the new FR lib.\n*/\n\n/* AD&D rules:",
            "context": "From FluffOS at line 4",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\std\\adversary\\formula\\skills.c",
            "code": "/* Do not remove the headers from this file! see /USAGE for more info. */\n\n// This is a simple skills module, demonstrating one way to integrate the\n// Lima skills system into the combat system\n// It is designed to return a number in the range 0 to 100 for chance to hit,\n// based on skills in the range 0 to MAX_SKILL_VALUE\n\n#include <combat_modules.h>\n#include <skills.h>\n",
            "context": "From FluffOS at line 3",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From MudOS at line 102",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From MudOS at line 104",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": " */\n#ifdef _SEQUENT_\n#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS",
            "context": "From FluffOS at line 96",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\portability.h",
            "code": "#  define GET_PROCESS_STATS\n#endif\n\n/*\n * Most implementation of System V Release 3 do not provide Berkeley signal\n * semantics by default.  Instead, POSIX signals are provided.  If your\n * implementation is System V Release 3 and you do not have Berkeley signals,\n * but you do have POSIX signals, then #define USE_POSIX_SIGNALS.\n */\n#if (defined(_SEQUENT_) || defined(_M_UNIX))\n#  define USE_POSIX_SIGNALS\n#endif\n",
            "context": "From FluffOS at line 98",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dgd-master\\dgd-master\\src\\ed\\line.h",
            "code": " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *   The basic data type is a line buffer, in which blocks of lines are\n * allocated. The line buffer can be made inactive, to make it use as little\n * system resources as possible.\n *   Blocks can be created, deleted, queried for their size, split in two, or\n * concatenated.\n */\ntypedef Int Block;\n\nclass LineBuf : public Allocated {",
            "context": "From DGD at line 22",
            "driver": "DGD"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "#define SAFE(x) do { x } while (0)\n \n\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1",
            "context": "From Unknown at line 47",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\extra\\wolfpaw\\macros.h",
            "code": "\n/*\n   Define for MALLOC, FREE, REALLOC, and CALLOC depend upon what malloc\n   package and optional wrapper is used.  This technique is used because\n   overlaying system malloc with another function also named malloc doesn't\n   work on most mahines that have shared libraries.  It will also let\n   us keep malloc stats even when system malloc is used.\n\n   Please refer to options.h for selecting malloc package and wrapper.\n*/\n#if (defined(SYSMALLOC) + defined(SMALLOC) + defined(BSDMALLOC) + defined(MMALLOC)) > 1\n!Only one malloc package should be defined\n#endif",
            "context": "From Unknown at line 49",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 0.75,
      "quality_score": 0.72048575,
      "timestamp": "2026-01-25T17:36:28.948796400+00:00"
    },
    {
      "model_name": "qwen2.5-coder:7b",
      "query": "Show me the correct syntax for query_* functions",
      "response": "Certainly! Below is an example of how to implement a `query_*` function in MudOS/FluffOS using the patterns from references. This example assumes you are working within a mudlib and want to provide information about an object.\n\n### Example: Implementing `query_short`\n\nLet's say we have a room object, and we want to provide a short description of it. We'll implement a `query_short` function that returns this description.\n\n#### Step 1: Define the Function Signature\n\nFirst, we need to define the function signature in our header file (e.g., `room.h`):\n\n```c\n#ifndef ROOM_H\n#define ROOM_H\n\n// Include necessary headers\n#include <std/object.h>\n\n// Declare the query_short function\nstring query_short();\n\n#endif // ROOM_H\n```\n\n#### Step 2: Implement the Function\n\nNext, we implement the `query_short` function in our object file (e.g., `room.c`):\n\n```c\n#include \"room.h\"\n\n// Define the query_short function\nstring query_short() {\n    return \"A dimly lit room with cobblestone walls and a flickering torch on the wall.\";\n}\n```\n\n#### Step 3: Use the Function\n\nFinally, you can use this `query_short` function in other parts of your mudlib or driver code. For example, if you want to display the short description when a player enters the room:\n\n```c\n#include \"room.h\"\n\n// Example usage in another object or efun\nvoid enter_room(object player) {\n    string short_desc = query_short();\n    message(\"environment\", \"$N steps into the room and sees: \" + short_desc, player);\n}\n```\n\n### Explanation\n\n1. **Header File (`room.h`)**:\n   - We define the function signature `string query_short();`.\n   - This header file is included in any object that needs to use or implement this function.\n\n2. **Implementation File (`room.c`)**:\n   - We include the header file to ensure we have access to the function declaration.\n   - We define the `query_short` function, which returns a string describing the room's short description.\n\n3. **Usage**:\n   - In other parts of your mudlib or driver code, you can call `query_short()` to get the short description of the room and use it as needed (e.g., displaying it to players).\n\nThis pattern ensures that your `query_*` functions are consistent with MudOS/FluffOS conventions and can be easily reused across different objects in your mudlib.",
      "response_time_ms": 10829,
      "tokens_per_second": 41.776356,
      "validation_result": {
        "query": "Show me the correct syntax for query_* functions",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "line_number": 4636,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "relevance_score": 0.57857144,
            "snippet": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "line_number": 1105,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "relevance_score": 0.57857144,
            "snippet": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "line_number": 540,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "line_number": 2187,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "relevance_score": 0.57857144,
            "snippet": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "line_number": 71,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "relevance_score": 0.57857144,
            "snippet": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "line_number": 145,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "relevance_score": 0.57857144,
            "snippet": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "line_number": 27,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "line_number": 31,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "line_number": 35,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "line_number": 59,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "line_number": 25,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "relevance_score": 0.57857144,
            "snippet": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "line_number": 1153,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "relevance_score": 0.57857144,
            "snippet": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "line_number": 280,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "line_number": 109,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "line_number": 57,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "line_number": 23,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "relevance_score": 0.57857144,
            "snippet": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "line_number": 22,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "relevance_score": 0.57857144,
            "snippet": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "line_number": 18,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "line_number": 17,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "line_number": 293,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "relevance_score": 0.57857144,
            "snippet": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "line_number": 26,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.62657136,
        "validation_score": 0.39600003,
        "sources_consulted": 25,
        "efuns_found": [
          "LE",
          "LOG",
          "NE",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly,\n   we know if this _was_ an aliased function, it must point to\n   to the correct definition already in prog\n   If this is not the first time it occurs, use overload_function\n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym\n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "  while (line_tmp > *p1) {\n    line_tmp -= *p1;\n    p1 += 2;\n  }\n  file = p1[1];\n\n  /* now correct the line number for that file */\n  p2 = file_info;\n  while (p2 < p1) {\n    if (p2[1] == file)\n      line_tmp += *p2;\n    p2 += 2;\n  }",
            "context": "From FluffOS at line 4636",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\db.c",
            "code": "\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treturn &the_null_array;\n\t\t}\n\t}\n\n\t/* SQLite v2 does not provide any functions for obtaining the values based on\n\t * their datatypes like v3 does.  It is completely typeless and everything is\n\t * returned as a (char *).  Thus we need a way of determining if the value is\n\t * numeric or a string.  I do make some assumptions here, but all in all it\n\t * does work for the vast majority of cases.  There is no support for blobs\n\t * to be returned as LPC buffers with v2.  Support for binary data in v2 is\n\t * suspect at best and is not recommended anyway, if you need that use v3.",
            "context": "From FluffOS at line 1105",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\mudlib_stats.c",
            "code": "    restore_stat_list(DOMAIN_STATS_FILE_NAME, &domains);\n    restore_stat_list(AUTHOR_STATS_FILE_NAME, &authors);\n}\n\n\n/*************************************\n * The following functions are the interface for efuns to get mappings\n * that describe the statistics for authors and domains.\n **************************************/\n\nstatic mapping_t *\n        get_info (mudlib_stats_t * dl)\n{",
            "context": "From FluffOS at line 540",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\packages\\parser.c",
            "code": "        }\n    }\n    if (!found_one && use_last_parallel_error(state))\n        m->token = ERROR_TOKEN;\n}\n\n/* Belgarat: The next functions are used for tests and error\n * reporting in the second pass of parsing when all parameters are exactly\n * filled (including the object ones)\n */\nstatic int cache_last_parallel_error(parser_error_t *storage) {\n    if (!parallel_error_info.error_type) \n        return 0;",
            "context": "From FluffOS at line 2187",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\parse.c",
            "code": "  especially true when the 'names' are not single words but phrases.\n\n  The third is very nice to have because it makes constructs like\n  'get all the little blue ones' possible.\n\n  Apart from these functions that should exist in all objects, and which\n  are therefore best put in /std/object.c there is also a set of functions\n  needed in /secure/master.c These are not absolutely necessary but they\n  give extra power to the efun.\n\n  Basically these /secure/master.c lfuns are there to give default values\n  for the lists of names fetched from each object.\n",
            "context": "From FluffOS at line 71",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\examples\\room\\exroom4.c",
            "code": "    return 1;\n}\n\n\n/* CODING STYLE 101\n   Personally, I always put my post/pre exit functions right after create and \n   before the reset() or init() functions.  This makes them easy to find.\n   Since they're MENTIONED in the create() I like to keep 'em close at hand.\n   For the same reason I usually follow my init() with any add_actions that\n   I've created.  I also preface my functions with an indicator saying what\n   their purpose is.  I've chosen aa_ for add_actions an pe_ for pre or post\n   exit functions.  OR i use pre_ or post_ when i have both going on.  This\n   may not seem like a big deal in a little file, but when the file gets ",
            "context": "From Unknown at line 145",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\obj\\mon\\execution_d.c",
            "code": "//  /domains/stanadard/obj/mon/execution.c\n//  Execution functions for the mortal law system\n//  Created 940917 by Manny@Nightmare\n\n#include <lib.h>\n#include <dirs.h>\n\ninherit DAEMON;",
            "context": "From Unknown at line 1",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    namen=ob->GetId();\n    if(member_array(\"bullet\",namen) == -1){\n        write(\"Only bullets fit into the magazine.\");\n        return 0;\n    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetAmmoType() != this_object()->GetAmmoType() ){\n        write(\"That round is not the correct type for the magazine.\");\n        return 0;\n    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }",
            "context": "From Unknown at line 31",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\clip.c",
            "code": "    }\n    if(ob->GetMillimeter() != this_object()->GetMillimeter() ){\n        write(\"That round is not the correct size for the magazine.\");\n        return 0;\n    }\n    if(ob->GetCaliber() != this_object()->GetCaliber() ){\n        write(\"That round is not the correct caliber for the magazine.\");\n        return 0;\n    }\n    if(ob->GetFirearmType() != \"auto\"){\n        write(\"That round is not a semiautomatic round.\");\n        return 0;\n    }",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\lib\\exits.c",
            "code": "        }\n    }\n    else if(query_verb() == \"crawl\"){\n        if( who->GetPosition() != POSITION_LYING &&\n                who->GetPosition() != POSITION_KNEELING &&\n                who->GetPosition() != POSITION_SITTING ){\n            write(\"You are not in the correct position for crawling.\");\n            return 0;\n        }\n    }\n    else if(query_verb() == \"fly\"){\n        if( who->GetPosition() != POSITION_FLYING ){\n            write(\"You are not flying.\");",
            "context": "From Unknown at line 59",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\powers\\prayers\\healing.c",
            "code": "    SetSpellType(SPELL_HEALING);\n    SetRequiredMagic(300);\n    SetSkills(([ \"healing\" : 1 ]));\n    SetMagicCost( 20, 10);\n    SetDifficulty(1);\n    SetVerb(\"pray\");\n    SetHelp(\"Syntax: <pray for healing for LIV>\\n\\n\"\n            \"This minor healing spell provides some minimal \"\n            \"aid to the wounded.\");\n}\n\nint eventCast(object who, int level, mixed limbs, object array targets) {\n    object target = targets[0];",
            "context": "From Unknown at line 25",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\admins\\admintool.c",
            "code": "        Menu();\n        return 1;\n    }\n\n    write(str);\n    global_group_temp = str;\n    write(\"The group format must be entered correctly. If the members are larry, moe, and curly, enter:\\n\");\n    write(\"larry:moe:curly\\n\");\n    write(\"\\nIt's important to put those colons between names. If the only member is shemp, enter:\\n\");\n    write(\"shemp\\n\");\n    write(\"\\nWhat would you like that group to contain?\\n\");\n    input_to ( (: eventEditGroup :) );\n    return 1;",
            "context": "From Unknown at line 1153",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\addemote.c",
            "code": "        \"things), and STR (for any arbitrary string).  In addition, the \"\n            \"rule can contains prepositions like to, at, on, about, etc.  \"\n            \"For example, to allow a player to do <smile at descartes>, you \"\n            \"need the parse rule <at LIV> or <at LVS>.  <smile oddly at \"\n            \"descartes> would be <STR at LIV> or <STR at LVS>.\\n\"\n            \"In general, you should allow players to enter in commands using \"\n            \"correct English and a syntax without prepositions.  For \"\n            \"example, since we have <at LVS>, we should also allow \"\n            \"<LVS>.  To support identical rules like this, when the \"\n            \"<addemote> command asks for a parser rule, you can enter in \"\n            \"multiple identical rules on the same line, separated by \"\n            \"commas:\\n\"\n            \"Enter parser rule: at LVS,LVS\\n\\n\"",
            "context": "From Unknown at line 280",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"This command allows you to add the most common kinds of \"\n            \"emote straight from the command line.  Using the first syntax, \"\n            \"You can add a simple, untargetted emote.  For example, \"\n            \"if you did <stupidemote cheese>, this would create an emote \"\n            \"that would allow people to do <cheese> and <cheese adverb> \"\n            \"with a message that looks like \\\"Descartes cheeses.\\\"\\n\"\n            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\players\\history.c",
            "code": "            \"quick access to execute or modify previous commands.  The size \"\n            \"of your command buffer defaults to \" + MIN_HISTORY_SIZE + \" but \"\n            \"may be expanded to \" + MAX_HISTORY_SIZE + \" if you desire.  You \"\n            \"can change the size of your history buffer by passing the size \"\n            \"as an argument to the history command.  Without arguments, the \"\n            \"command simply prints the commands in your history buffer.\\n\\n\"\n            \"The following syntaxes are available for accessing previously \"\n            \"issued commands:\\n\"\n            \"\\t!!\\t\\texecute the last command\\n\"\n            \"\\t!#\\t\\texecute command number #\\n\"\n            \"\\t!-#\\t\\texecute #th command prior\\n\"\n            \"\\t^old^new\\treplace 'old' with 'new' in last command and \"\n            \"execute\\n\"",
            "context": "From Unknown at line 57",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\daemon\\function.c",
            "code": "\nstatic private void validate() {\n    if(!this_player()) return 0;\n    if( !(master()->valid_apply(({ \"ASSIST\" }))) )\n        error(\"Illegal attempt access FUNCTIONS_D: \"+get_stack()+\" \"+identify(previous_object(-1)));\n    if(query_os_type() == \"windows\"){\n        error(\"The functions daemon has been disabled for your mud \"+\n                \"because it is running on windows. Intensive file operations \"+\n                \"in windows are not yet supported on Dead Souls.\");\n    }\n}\n\nvoid heart_beat(){",
            "context": "From Unknown at line 23",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\verbs\\creators\\force.c",
            "code": "\nstatic void create() {\n    verb::create();\n    SetVerb(\"force\");\n    SetRules(\"LIV STR\", \"LIV to STR\");\n    SetErrorMessage(\"Force whom to do what?\");\n    SetHelp(\"Syntax: <force LIVING SOMETHING>\\n\"\n            \"        <force LIVING to DO SOMETHING>\\n\"\n            \"Allows you to command some living things to do \"\n            \"your bidding.\");\n}\n\nmixed can_force_liv_to_str(string str) { ",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\items\\remove.c",
            "code": "    SetErrorMessage(\"Remove what?\");\n    SetHelp(\"Syntax: <remove ARMOR>\\n\"\n            \"        <remove all [of ARMOR]>\\n\"\n            \"        <remove ITEM from CONTAINER>\\n\\n\"\n            \"This verb allows you to remove a piece of armor which you are \"\n            \"currently wearing.\\n\\n\"\n            \"The second syntax is simply a synonym for the \\\"get\\\" \"\n            \"command.\\n\\n\"\n            \"See also: get, wear, wield, unwield\");\n    SetSynonyms(\"take off\", \"unwear\");\n}\n\nmixed can_remove_obj() {",
            "context": "From Unknown at line 22",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\pray.c",
            "code": "static void create() {\n    verb::create();\n    SetVerb(\"pray\");\n    SetRules(\"for STR\", \"for STR against STR\", \"for STR against STR for LIV\",\n            \"for STR for OBJ\");\n    SetErrorMessage(\"Pray for what?\");\n    SetHelp(\"Syntax: pray for <PRAYER>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING>\\n\"\n            \"        pray for <PRAYER> against <SOMETHING> for <SOMEONE>\\n\\n\"\n            \"Allows you to say a prayer to whatever deity you believe in.\\n\"\n            \"See also: prayers\");\n}\n",
            "context": "From Unknown at line 18",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\verbs\\players\\vote.c",
            "code": "\nstatic void create(){\n    verb::create();\n    SetVerb(\"vote\");\n    SetRules(\"for STR\");\n    SetErrorMessage(\"For whom would you like to vote?\");\n    SetHelp(\"Syntax: vote for <STR>\\n\\n\"\n            \"Casts your vote for a candidate if in a voting place.\");\n}\n\nmixed can_vote_for_str(){\n    object env;\n    mixed  err;",
            "context": "From Unknown at line 17",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\compiler.c",
            "code": "   Because program prog is assumed to be dealt with correctly, \n   we know if this _was_ an aliased function, it must point to \n   to the correct definition already in prog \n   If this is not the first time it occurs, use overload_function \n   Otherwise, consistency cannot be guaranteed. The resulting\n   first time copy will never be aliased, as it's presence will\n   be a magic marker for other similar functions that will get\n   removed. - Sym \n */\n\nstatic void copy_new_function (program_t * prog, int index,\n                                 program_t * defprog, int defindex,\n                                 int typemod) {",
            "context": "From FluffOS at line 293",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\gnumalloc.h",
            "code": "/* The allocator divides the heap into blocks of fixed size; large\n   requests receive one or more whole blocks, and small requests\n   receive a fragment of a block.  Fragment sizes are powers of two,\n   and all fragments of a block are the same size.  When all the\n   fragments in a block have been freed, the block itself is freed.\n   WARNING: BLOCKSIZE must be set greater than or equal to the\n   machine's page size for valloc() to work correctly.  The default\n   definition here is 4096 bytes. */\n#define INT_BIT (CHAR_BIT * sizeof (int))\n#define BLOCKLOG (INT_BIT > 16 ? 12 : 9)\n#define BLOCKSIZE (1 << BLOCKLOG)\n#define BLOCKIFY(SIZE) (((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)\n",
            "context": "From FluffOS at line 26",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 1.0,
      "quality_score": 0.6822571,
      "timestamp": "2026-01-25T17:36:39.777921200+00:00"
    },
    {
      "model_name": "qwen2.5-coder:7b",
      "query": "What's the difference between call_other() and call_out()?",
      "response": "```c\n/**\n * @file call_functions.c\n * @brief Implementation of call_other() and call_out() functions for LPC driver.\n *\n * These functions allow LPC programs to invoke other objects or functions asynchronously.\n */\n\n#include \"driver.h\"\n#include \"object.h\"\n\n/**\n * Calls another object's function synchronously.\n *\n * @param ob The object whose function is to be called.\n * @param func_name The name of the function to call.\n * @param ... Variable arguments to pass to the function.\n * @return The result of the function call, if any.\n */\nmixed call_other(object ob, string func_name, ...)\n{\n    va_list args;\n    mixed result;\n\n    // Check if the object is valid\n    if (!ob || !objectp(ob)) {\n        error(\"Invalid object passed to call_other.\\n\");\n    }\n\n    // Prepare variable arguments list\n    va_start(args, func_name);\n\n    // Call the function on the object with the provided arguments\n    result = vsprintf(func_name, args);\n\n    // Clean up the variable arguments list\n    va_end(args);\n\n    return result;\n}\n\n/**\n * Calls another object's function asynchronously after a specified delay.\n *\n * @param ob The object whose function is to be called.\n * @param func_name The name of the function to call.\n * @param delay The delay in seconds before the function is called.\n * @param ... Variable arguments to pass to the function.\n */\nvoid call_out(object ob, string func_name, int delay, ...)\n{\n    va_list args;\n    mixed result;\n\n    // Check if the object is valid\n    if (!ob || !objectp(ob)) {\n        error(\"Invalid object passed to call_out.\\n\");\n    }\n\n    // Prepare variable arguments list\n    va_start(args, delay);\n\n    // Schedule a call to the function on the object with the provided arguments and delay\n    schedule_call(ob, func_name, args, delay);\n\n    // Clean up the variable arguments list\n    va_end(args);\n}\n\n/**\n * Helper function to schedule a call to an object's function.\n *\n * @param ob The object whose function is to be called.\n * @param func_name The name of the function to call.\n * @param args Variable arguments to pass to the function.\n * @param delay The delay in seconds before the function is called.\n */\nvoid schedule_call(object ob, string func_name, va_list args, int delay)\n{\n    // Create a new call frame with the object, function name, and arguments\n    call_frame_t *frame = create_call_frame(ob, func_name, args);\n\n    // Schedule the call frame for execution after the specified delay\n    schedule_delayed_call(frame, delay);\n}\n\n/**\n * Creates a new call frame for an object's function.\n *\n * @param ob The object whose function is to be called.\n * @param func_name The name of the function to call.\n * @param args Variable arguments to pass to the function.\n * @return A pointer to the newly created call frame.\n */\ncall_frame_t *create_call_frame(object ob, string func_name, va_list args)\n{\n    call_frame_t *frame = allocate(sizeof(call_frame_t));\n\n    // Initialize the call frame with the object, function name, and arguments\n    frame->object = ob;\n    frame->function_name = func_name;\n    frame->args = args;\n\n    return frame;\n}\n\n/**\n * Schedules a call frame for execution after a specified delay.\n *\n * @param frame The call frame to schedule.\n * @param delay The delay in seconds before the function is called.\n */\nvoid schedule_delayed_call(call_frame_t *frame, int delay)\n{\n    // Add the call frame to the event queue with the specified delay\n    add_to_event_queue(frame, delay);\n}\n\n/**\n * Event handler for delayed function calls.\n *\n * @param frame The call frame to execute.\n */\nvoid handle_delayed_call(call_frame_t *frame)\n{\n    object ob = frame->object;\n    string func_name = frame->function_name;\n    va_list args = frame->args;\n\n    // Call the function on the object with the provided arguments\n    vsprintf(func_name, args);\n\n    // Free the call frame after execution\n    free_call_frame(frame);\n}\n\n/**\n * Frees a call frame.\n *\n * @param frame The call frame to free.\n */\nvoid free_call_frame(call_frame_t *frame)\n{\n    // Free the memory allocated for the call frame\n    free(frame);\n}\n```",
      "response_time_ms": 30114,
      "tokens_per_second": 26.073412,
      "validation_result": {
        "query": "What's the difference between call_other() and call_out()?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 115,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "relevance_score": 0.72142863,
            "snippet": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "line_number": 10,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "line_number": 36,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "relevance_score": 0.72142863,
            "snippet": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "line_number": 35,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "relevance_score": 0.72142863,
            "snippet": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "line_number": 114,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "relevance_score": 0.72142863,
            "snippet": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "line_number": 109,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "line_number": 85,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "line_number": 93,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "line_number": 102,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "relevance_score": 0.58571434,
            "snippet": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "line_number": 157,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "line_number": 230,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.58571434,
            "snippet": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "line_number": 246,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.9048573,
        "validation_score": 0.804,
        "sources_consulted": 25,
        "efuns_found": [
          "CALL_OTHER",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\Praxis\\mage_join.c",
            "code": "             \"walls\" : \"They are made from the wood of this old tree. An \"\n             \"opening leads outside.\",\n             \"stairs\" : \"They are very nice.\",\n             \"torch\" : \"It is locked magically into the wall.\",\n             \"warlock\" : \"He awaits to initiate new mages.\",\n             \"mage\" : \"He awaits to initiate new mages and explain \"\n             \"the difference between transitive and intransitive verbs.\",\n             \"opening\" : \"It leads out to West Road.\",\n             \"torches\" : \"They create an eerie glow to the room.\"]) );\n    SetExits( \n            ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    AddExit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\fluffos-2.7-ds2.018\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsI\\dsI\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 109",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\fluffos-2.16-ds05\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\dsIIr10\\dsIIr10\\lib\\secure\\cmds\\creators\\stupidemote.c",
            "code": "            \"The second syntax is for targetted emotes.  You specify a \"\n            \"targetting rule.  Targetting rules can be one of the following:\\n\"\n            \"\\t* LIV\\n\"\n            \"\\t* LVS\\n\"\n            \"\\t* preposition LIV\\n\"\n            \"\\t* preposition LVS\\n\"\n            \"The difference between LIV and LVS just determines whether the \"\n            \"emote can be targetted at a single living being or one or more \"\n            \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n            \"do:\\n\"\n            \"> stupidemote smile at LVS\\n\"\n            \"and that would give you all the functionality of the \\\"smile\\\" \"\n            \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From Unknown at line 115",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\fluffos-2.9-ds2.11\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\driver\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\lima_fluffos_v1\\lima_fluffos_v1\\lib\\domains\\std\\school\\R\\edtutor06.c",
            "code": "\nvoid setup(){\n  set_brief(\"Ed Tutorial 6\");\n  set_long(@MAY\nThe add and insert commands <a> and <i> are quite\nsimilar.  They both put you in to the 'add text' mode.\nThe difference between the 2 commands is where the new\ntext will be placed.  When using the <a> command, the new\nlines are put AFTER the specified line.  If no line # is\ngiven, then the text is put after the CURRENT line.\nThe <i> command works similarly but the text is INSERTED\nBEFORE the specified line.  The same holds true if no\nline number is given.",
            "context": "From FluffOS at line 10",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\merentha_fluffos_v2\\merentha_fluffos_v2\\fluffos-2.9-ds2.03\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\mudos_v22.2b14-ds2\\mudos_v22.2b14-ds2\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From Unknown at line 36",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare-3.3.1\\Nightmare-3.3.1\\mudlib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From Unknown at line 35",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:go_down:));\n}",
            "context": "From MudOS at line 36",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\lib\\domains\\Praxis\\standardOld\\mage_join.c",
            "code": "\t  \"walls\" : \"They are made from the wood of this old tree. An \"\n\t    \"opening leads outside.\",\n\t  \"stairs\" : \"They are very nice.\",\n\t  \"torch\" : \"It is locked magically into the wall.\",\n\t  \"warlock\" : \"He awaits to initiate new mages.\",\n\t  \"mage\" : \"He awaits to initiate new mages and explain \"\n\t    \"the difference between transitive and intransitive verbs.\",\n\t  \"opening\" : \"It leads out to West Road.\",\n\t  \"torches\" : \"They create an eerie glow to the room.\"]) );\n    set_exits( \n\t      ([\"out\" :\t\"/domains/Praxis/west_road3\"]) );\n    add_exit(\"down\", \"/domains/Praxis/mage_hall.c\", (:\"go_down\":));\n}",
            "context": "From MudOS at line 35",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare3_mudos_v1\\nightmare3_mudos_v1\\source\\bsdmalloc.c",
            "code": "\nstatic void morecore PROT((int));\nstatic int findbucket PROT((union overhead *, int));\n\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From MudOS at line 114",
            "driver": "MudOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\fluffos-2.9-ds2.14\\bsdmalloc.c",
            "code": "\nstatic void morecore (int);\nstatic int findbucket (union overhead *, int);\nvoid *sbrkx(long);\n#ifdef DO_MSTATS\n/*\n * nmalloc[i] is the difference between the number of mallocs and frees\n * for a given block size.\n */\nstatic u_int nmalloc[NBUCKETS];\n\n#endif\n",
            "context": "From FluffOS at line 114",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\nightmare4_fluffos_v1\\nightmare4_fluffos_v1\\lib\\secure\\cmds\\admins\\stupidemote.c",
            "code": "\t    \"The second syntax is for targetted emotes.  You specify a \"\n\t    \"targetting rule.  Targetting rules can be one of the following:\\n\"\n\t    \"\\t* LIV\\n\"\n\t    \"\\t* LVS\\n\"\n\t    \"\\t* preposition LIV\\n\"\n\t    \"\\t* preposition LVS\\n\"\n\t    \"The difference between LIV and LVS just determines whether the \"\n\t    \"emote can be targetted at a single living being or one or more \"\n\t    \"living beings.  So, to add the \\\"smile\\\" emote, you would \"\n\t    \"do:\\n\"\n\t    \"> stupidemote smile at LVS\\n\"\n\t    \"and that would give you all the functionality of the \\\"smile\\\" \"\n\t    \"emote that exists on this mudlib.\\n\\n\"",
            "context": "From FluffOS at line 109",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    adjid_list_d = master()->parse_command_adjectiv_id_list();\n    prepos_list = master()->parse_command_prepos_list();\n    \n    allword = master()->parse_command_all_word();\n    \n    /*\n     * Loop through the pattern. Handle %s but not '/'\n     */\n    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {",
            "context": "From FluffOS at line 85",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "    for (six = 0, cix = 0, pix = 0; pix < sizeof(parse_patarr); pix++) {\n\tvalue = 0;\n\tfail = 0;\n\t\n\tif (parse_patarr[pix] == \"%s\") {\n\t    /*\n\t     * We are at end of pattern, scrap up the remaining words and put\n\t     * them in the fill-in value.\n\t     */\n\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {",
            "context": "From FluffOS at line 93",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t    if (pix == sizeof(parse_patarr - 1)) {\n\t\tstore_words_slice(six++, parse_warr, cix, sizeof(parse_warr) - 1);\n\t\tcix = sizeof(parse_warr);\n\t    } else {\n\t\t/*\n\t\t * There is something after %s, try to parse with the next\n\t\t * pattern. Begin with the current word and step one word for\n\t\t * each fail, until match or end of words.\n\t\t */\n\t\tocix = fword = cix; /* current word */\n\t\tfpix = ++pix; /* pix == next pattern */\n\t\tdo {\n\t\t    /*",
            "context": "From FluffOS at line 102",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compat\\simuls\\parse_command.c",
            "code": "\t */\n\tif (fail)\n\t    break;\n    }\n\n    /*\n     * Also fail when there is words left to parse and pattern exhausted\n     */\n    if (fail || cix < sizeof(parse_warr))\n\treturn 0;\n\n    cret = ret;\n    ret = saved_ret;",
            "context": "From FluffOS at line 157",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        free_array(arg->u.arr);\n        sp->u.arr = ret;\n        return;\n    } else {\n        ob = find_object(arg[0].u.string);\n        if (!ob || !object_visible(ob))\n            error(\"call_other() couldn't find object\\n\");\n    }\n    /* Send the remaining arguments to the function. */\n#ifdef TRACE\n    if (TRACEP(TRACE_CALL_OTHER)) {\n        do_trace(\"Call other \", funcname, \"\\n\");\n    }",
            "context": "From FluffOS at line 230",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "        pop_2_elems();\n        push_undefined();\n        return;\n    }\n    /*\n     * The result of the function call is on the stack.  So is the function\n     * name and object that was called, though. These have to be removed.\n     */\n    free_svalue(--sp, \"f_call_other:1\");\n    free_svalue(--sp, \"f_call_other:2\");\n    *sp = *(sp+2);\n    return;\n}",
            "context": "From FluffOS at line 246",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 1.0,
      "quality_score": 0.7943143,
      "timestamp": "2026-01-25T17:37:09.892927300+00:00"
    },
    {
      "model_name": "qwen2.5-coder:7b",
      "query": "Generate a basic room inherit for the std/room.c",
      "response": "Certainly! Below is an example of a basic room inherit using `std/room.c` in a MUDlib. This template provides a starting point with essential functions and properties that you can customize further.\n\n```c\ninherit \"/std/room\";\n\nvoid setup() {\n    // Set the short description of the room\n    set_short(\"A Basic Room\");\n\n    // Set the long description of the room\n    set_long(@LONG\nYou find yourself in a basic room. The walls are painted a dull gray, and there is a faint smell of old wood. \nThere is a single door leading north.\nLONG);\n\n    // Add items to the room\n    add_item(\"walls\", \"The walls are covered in peeling paint.\");\n    add_item(\"door\", \"A wooden door leads north.\");\n\n    // Set the light level in the room (10-90)\n    set_light(50);\n\n    // Add smells, feels, and tastes to enhance the atmosphere\n    add_smell(\"air\", \"The air is stale and musty.\");\n    add_feel(\"floor\", \"The floor is rough and worn.\");\n    add_taste(\"wall\", \"You touch the wall and feel a hint of dust.\");\n\n    // Set the exits from this room\n    add_exit(\"/path/to/north_room\", \"north\");\n}\n\nvoid init() {\n    ::init();\n    // Add any additional initialization code here if needed\n}\n```\n\n### Explanation:\n- **`set_short()`**: Sets a brief description of the room.\n- **`set_long()`**: Provides a detailed description of the room, which is displayed when a player looks around.\n- **`add_item()`**: Adds descriptions for various items in the room. You can add multiple items at once by passing an array as the first argument.\n- **`set_light()`**: Sets the light level in the room. The value ranges from 10 (very dark) to 90 (very bright).\n- **`add_smell()`, `add_feel()`, `add_taste()`**: These functions add sensory descriptions that enhance the player's experience.\n- **`add_exit()`**: Defines exits from the current room, linking it to other rooms.\n\n### Customization:\nYou can customize this template by adding more items, smells, feels, tastes, and setting different light levels. You can also add additional initialization code in the `init()` function if needed.\n\nThis basic setup provides a solid foundation for creating more complex and immersive rooms in your MUD.",
      "response_time_ms": 18815,
      "tokens_per_second": 22.593596,
      "validation_result": {
        "query": "Generate a basic room inherit for the std/room.c",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "relevance_score": 0.72142863,
            "snippet": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "line_number": 0,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "relevance_score": 0.57857144,
            "snippet": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "line_number": 222,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "relevance_score": 0.57857144,
            "snippet": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "line_number": 2555,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "relevance_score": 0.57857144,
            "snippet": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "line_number": 2384,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "relevance_score": 0.57857144,
            "snippet": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "line_number": 2945,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 655,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "relevance_score": 0.57857144,
            "snippet": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "line_number": 819,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "relevance_score": 0.57857144,
            "snippet": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "line_number": 643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "relevance_score": 0.57857144,
            "snippet": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "line_number": 16,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "line_number": 202,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "relevance_score": 0.57857144,
            "snippet": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "line_number": 357,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "relevance_score": 0.57857144,
            "snippet": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "line_number": 54,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "relevance_score": 0.57857144,
            "snippet": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "line_number": 89,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "relevance_score": 0.57857144,
            "snippet": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "line_number": 27,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "relevance_score": 0.57857144,
            "snippet": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "line_number": 32,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "line_number": 325,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "line_number": 331,
            "validation_status": "Verified"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "relevance_score": 0.57857144,
            "snippet": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "line_number": 338,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "relevance_score": 0.57857144,
            "snippet": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "line_number": 9,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "relevance_score": 0.57857144,
            "snippet": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "line_number": 29,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "relevance_score": 0.57857144,
            "snippet": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "line_number": 9,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "relevance_score": 0.57857144,
            "snippet": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "line_number": 88,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "line_number": 101,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "line_number": 108,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "relevance_score": 0.57857144,
            "snippet": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "line_number": 120,
            "validation_status": "CrossReferenced"
          }
        ],
        "confidence_score": 0.6622856,
        "validation_score": 0.46800002,
        "sources_consulted": 25,
        "efuns_found": [
          "GE",
          "LE",
          "MOD",
          "OK",
          "OR",
          "SIZE",
          "add_a",
          "replace",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\final_realms_fluffos_v1\\final_realms_fluffos_v1\\lib\\std\\creator\\workroom2.c",
            "code": "/* Additional workroom for newbie Builders.  This one is basically the\n * the same as workroom.c but has stripped out descriptions but added\n  in add_action()'s so you can \"move desk\" or whatever in your \n * workrooms.\n * Radix : September 27, 1995\n */\n",
            "context": "From FluffOS at line 0",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\compiler.c",
            "code": "    offset = locals_ptr - locals;\n    locals = RESIZE(locals, locals_size,\n                    local_info_t, TAG_LOCALS, \"reallocate_locals:2\");\n    locals_ptr = locals + offset;\n}\n\n/* Fix a inherited class type for the current program */\nstatic void fix_class_type (int * t, program_t * from) {\n    ident_hash_elem_t *ihe;\n    int num;\n\n    if ((*t) & TYPE_MOD_CLASS) {\n        ihe = lookup_ident(from->strings[from->classes[(*t) & CLASS_NUM_MASK].classname]);",
            "context": "From FluffOS at line 222",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\ed.c",
            "code": "        ED_OUTPUT(ED_DEST, \"\\\nAutomatic Indentation (V 1.0)\\n\\\n------------------------------------\\n\\\nby Qixx [Update: 7/10/91]\\n\\n\\\nBy using the command 'I', a program is run which will\\n\\\nautomatically indent all lines in your code.  As this is\\n\\\nbeing done, the program will also search for some basic\\n\\\nerrors (which don't show up good during compiling) such as\\n\\\nUnterminated String, Mismatched Brackets and Parentheses,\\n\\\nand indented code is easy to understand and debug, since if\\n\\\nyour brackets are off -- the code will LOOK wrong. Please\\n\\\nmail me at gaunt@mcs.anl.gov with any pieces of code which\\n\\\ndon't get indented properly.\\n\");",
            "context": "From FluffOS at line 2555",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\efuns_main.c",
            "code": "}\n#endif                          /* F_RENAME */\n\n/* This is an enhancement to the f_replace_string() in efuns_main.c of\n   MudOS v21.  When the search pattern has more than one character,\n   this version of f_replace_string() uses a skip table to more efficiently\n   search the file for the search pattern (the basic idea is to avoid\n   strings comparisons where possible).  This version is anywhere from\n   15% to 40% faster than the old version depending on the size of the\n   string to be searched and the length of the search string (and depending\n   on the relative frequency with which the letters in the search string\n   appear in the string to be searched).\n",
            "context": "From FluffOS at line 2384",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\interpret.c",
            "code": "        /* Save all important global stack machine registers */\n        push_control_stack(FRAME_FUNCTION);\n        current_prog = current_object->prog;\n\n        caller_type = ORIGIN_LOCAL;\n        /*\n         * If it is an inherited function, search for the real\n         * definition.\n         */\n        csp->num_local_variables = EXTRACT_UCHAR(pc++) + num_varargs;\n        num_varargs = 0;\n\t//if(offset > USHRT_MAX)\n\t//error(\"Broken function table\"); offset is a USHRT, so this just can't happen!",
            "context": "From FluffOS at line 2945",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\",\\\"TERMINAL?\\0\", where '?'\n             * is unknown\n             */\n            if (len + termlen + 5 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\lex.c",
            "code": "                break;\n            }\n            if (c == '\\n') {\n                current_line++;\n            }\n            /*\n             * make sure there's room in the current chunk for terminator (ie\n             * it's simpler if we don't have to deal with a terminator that\n             * spans across chunks) fudge for \"\\\\nTERMINAL?\\0\", where '?' is\n             * unknown\n             */\n            if (len + termlen + 4 > MAXCHUNK) {\n                if (curchunk == NUMCHUNKS - 1) {",
            "context": "From FluffOS at line 819",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\options.h",
            "code": "#undef USE_POSTGRES\n#endif\n\n/****************************************************************************\n *                            UID PACKAGE                                   *\n *                            -----------                                   *\n * UIDS are the basis for some mudlib security systems.  Basically, they're *\n * preserved for backwards compatibility, as several ways of breaking       *\n * almost any system which relies on them are known.  (No, it's not a flaw  *\n * of uids; only that b/c of the ease with which LPC objects can call       *\n * each other, it's far too easy to leave holes)                            *\n *                                                                          *\n * If you don't care about security, the first option is probably what you  *",
            "context": "From FluffOS at line 643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\program.h",
            "code": " * 1. The program itself. Consists of machine code instructions for a virtual\n *    stack machine. The size of the program must not be bigger than\n *    65535 bytes, as 16 bit pointers are used. Who would ever need a bigger\n *    program :-)\n * 2. Function names. All local functions that has been defined or called,\n *    with the address of the function in the program. Inherited functions\n *    will be found here too, with information of how far up the inherit\n *    chain that the function was defined.\n * 3. String table. All strings used in the program. They are all pointers\n *    into the shared string area. Thus, they are easily found and deallocated\n *    when the object is destructed.\n * 4. Table of variable names. They all point into the shared string table.\n * 5. Line number information. A table which tells at what address every",
            "context": "From FluffOS at line 16",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": "     * objects path. That should be an object defined by another wizard. It\n     * can't be trusted, so we give it the same uid as the creator. Also give\n     * it eff_user 0, which means that user 'a' can't use objects from user\n     * 'b' to load new objects nor modify files owned by user 'b'.\n     *\n     * If this effect is wanted, user 'b' must let his object do 'seteuid()' to\n     * himself. That is the case for most rooms.\n     */\n    ob->uid = add_uid(creator_name);\n#ifdef AUTO_SETEUID\n    ob->euid = ob->uid;\n#else\n    ob->euid = NULL;",
            "context": "From FluffOS at line 202",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\simulate.c",
            "code": " * Load an object definition from file. If the object wants to inherit\n * from an object that is not loaded, discard all, load the inherited object,\n * and reload again.\n *\n * In mudlib3.0 when loading inherited objects, their reset() is not called.\n * - why is this??  it makes no sense and causes a problem when a developer\n * inherits code from a real used item.  Say a room for example.  In this case\n * the room is loaded but is never set up properly, so when someone enters it\n * it's all messed up.  Realistically, I know that it's pretty bad style to\n * inherit from an object that's actually being used and isn't just a building\n * block, but I see no reason for this limitation.  It happens, and when it\n * does occur, produces mysterious results than can be hard to track down.\n * for now, I've reenabled resetting.  We'll see if anything breaks. -WF",
            "context": "From FluffOS at line 357",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\creators\\exits.c",
            "code": "\n    return 1;\n}\n\nstring GetHelp(){ \n    return (\"Syntax: exits\\n\\nDisplays exit and enter \"\n            \"information for the current room.\");\n}",
            "context": "From Unknown at line 54",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\cmds\\players\\wimpy.c",
            "code": "            \"The \\\"on\\\" and \\\"off\\\" arguments are simply quick ways to \"\n            \"set the percentage to 23% and 0% respectively.  You cannot \"\n            \"Set yourself to wimpy at anything greater than 30%.\\n\"\n            \"If you set go and enter commands, for example:\\n\"\n            \"\\tgo west\\n\"\n            \"the wimpy system will first try to use that command, and if it \"\n            \"fails, it will search for an exit in the room to take.  If \"\n            \"you set another command as your wimpy command, however, other \"\n            \"than a go or enter, it will not make any attempt to execute \"\n            \"some other command.\\n\"\n            \"For example, if you issued the command:\\n\"\n            \"\\twimpy gate to Mystery Person\\n\"\n            \"so that \\\"gate to Mystery Person\\\" was your wimpy command, \"",
            "context": "From Unknown at line 89",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\finger.c",
            "code": "                    capitalize(packet[6]) + \" is not involved.\",\n                    packet }));\n        return;\n    }\n    ret = ({ \"finger-reply\", 5, mud_name(), 0, packet[2], packet[3] }) + ret;\n    INTERMUD_D->eventWrite(ret);\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has requested finger information about \"+capitalize(ret[6])+\".%^RESET%^\\\"\");\n    tn(\"eventReceiveFingerRequest: \"+identify(packet),\"cyan\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+\n            packet[2]+\" fingers \"+capitalize(ret[6])+ \"]\",0);\n}\n\nvoid eventReceiveFingerReply(mixed array packet) {",
            "context": "From Unknown at line 27",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\daemon\\services\\locate.c",
            "code": "void eventReceiveLocateRequest(mixed array packet) {\n    string status;\n    int idl = 0;\n    object ob;\n    PING_D->SetOK();\n    if( file_name(previous_object()) != INTERMUD_D ) return;\n    //tell_room(ROOM_ARCH,\"The Arch Room loudspeaker announces: \\\"%^BOLD%^CYAN%^\"+capitalize(packet[3])+\" at \"+packet[2]+\" has issued a locate request for %^BOLD%^YELLOW%^\"+capitalize(packet[6])+\".%^RESET%^\\\"\");\n    tn(\"Locate request received: \"+identify(packet),\"white\");\n    CHAT_D->eventSendChannel(\"SYSTEM\",\"intermud\",\"[\" + capitalize(packet[3])+\"@\"+packet[2]+\n            \" seeks \"+packet[6]+ \"]\",0);\n    if( !(ob = find_player(packet[6])) || ob->GetInvis()) return;\n    if( interactive(ob) ) {\n        string array tmp = ({ });",
            "context": "From Unknown at line 32",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        write (\"Only the mc may use the shield.\\n\") ;\n        return 1 ;\n    }\n    if(str==\"on\" || str == \"1\"){\n        load_object(base_name(environment(this_object())))->set_privacy( 1 );\n        write(\"You enable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");",
            "context": "From Unknown at line 325",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n        return 1;\n    }\n    if(str==\"off\" || str == \"0\"){\n        load_object(base_name(environment(this_object())))->AutoDeactivate();\n        write(\"You disable the privacy shield.\\n\");\n        say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {",
            "context": "From Unknown at line 331",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\obj\\podium.c",
            "code": "        return 1;\n    }\n}\n\n// Echoing is always forbidden. It's just too much of a hassle.\nint echo (string str) {\n    write (\"Echoing is forbidden in the conference room at all times.\\n\") ;\n    return 1 ;\n}\n\n// Permit_entry lets the mc bring someone into the conference room\n// when it is locked.\nint permit_entry (string name) {",
            "context": "From Unknown at line 338",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore.c",
            "code": "\nstatic void create() {\n    ::create();\n    SetClimate(\"indoors\");\n    SetAmbientLight(30);\n    SetShort(\"the campus bookstore\");\n    SetLong(\"This is the Virtual Campus Bookstore. It is a fairly small place, and in fact has few books available, since the campus is not open for classes yet. There is, however, a wide assortment of useful items available, which you can browse by typing the 'list' command. The storeroom is above. There is a sign on the wall behind the counter.\");\n    SetItems(([\n                ({\"store\",\"bookstore\",\"place\"}) : \"This is the Virtual Campus bookstore.\",\n                \"books\" : \"There aren't any yet. Weren't you paying attention?\",\n                ({\"assortment\",\"items\",\"stuff\"}) : \"To browse what you can buy, type: list.\",\n                \"counter\" : \"A cheap wood-textured counter designed to make the surrender \"+\n                \"of your money more convenient.\",",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\bookstore2.c",
            "code": "int CanReceive(object sneak) {\n    object *living_stack = get_livings(sneak);\n    if(!living_stack || !arrayp(living_stack)) living_stack = ({ sneak });\n    foreach(object ob in living_stack){\n        if(living(ob) && !creatorp(ob) &&\n                !member_group(ob,\"TEST\")) {\n            message(\"info\",\"The storeroom is for authorized personnel only.\", ob);\n            return 0;\n        }\n    }\n    return ::CanReceive(sneak);\n}\nvoid init(){",
            "context": "From Unknown at line 29",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\classroom1.c",
            "code": "inherit LIB_ROOM;\n\nvoid create() {\n    room::create();\n    SetAmbientLight(30);\n    SetShort(\"Science Classroom\");\n    SetLong(\"This small room provides a teaching space for the advanced topics researched by the facility.\");\n    SetClimate(\"indoors\");\n    SetItems( ([ \n                ]) );\n    SetExits(([\n                \"south\" : \"/domains/campus/room/science5\",\n                ]));",
            "context": "From Unknown at line 9",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf.c",
            "code": "    }\n    else write(capitalize(punk->GetKeyName())+\" is not on the ejected list.\");\n    return ejected_players;\n}\n\nstring ReadSign(){\n    string ret = \"This is a special room for the orderly administration of meetings. It uses a special podium to manage speaking, and prevents the receipt of channel messages. It also prevents teleporting in under some circumstances. If you are attending a meeting here, please try to be polite and avoid being disruptive. You are here by choice, so if you're bored, feel free to leave quietly. Some useful commands in this room:\\n\";\n    ret += \"raise : indicates you wish to speak.\\n\";\n    ret += \"agenda : displays the current agenda.\\n\\n\";\n    ret += \"Remember! Channels and some commands like \\\"call\\\" may \";\n    ret += \"not work here!\";\n    return ret;\n}",
            "context": "From Unknown at line 88",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   return 1;\n   }\n\n   if(str==\"on\" || str == \"1\"){\n   this_object()->set_privacy(1);\n   write(\"You enable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" enables a privacy force field around the room.\");\n   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");",
            "context": "From Unknown at line 101",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "   timer = time();\n   return 1;\n   }\n   if(str==\"off\" || str == \"0\"){\n   this_object()->set_privacy(0);\n   write(\"You disable the privacy shield.\\n\");\n   say(this_player()->GetName()+\" disables a privacy force field around the room.\");\n   timer = 0;\n   return 1;\n   }\n   }\n */\nint get_privacy(){",
            "context": "From Unknown at line 108",
            "driver": "Unknown"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\lib\\domains\\campus\\room\\conf2.c",
            "code": "int get_privacy(){\n    return privacy;\n}\n\nstring ExtraDesc(){\n    string extra = \"%^YELLOW%^A privacy force field is active around this room.%^RESET%^\";\n    string desc = \"This is an enchanted room, with the magical power to prevent uninvited people from entering. It is used for meetings where three or more people need to share information without interruption or privately. To enable privacy, 'privacy on'. To disable it, 'privacy off'. The privacy field automatically deactivates after approximately 20 minutes.\\n\";\n    if(privacy) return desc+extra;\n    else return desc+\"%^RED%^The privacy field is DISABLED.\";\n}",
            "context": "From Unknown at line 120",
            "driver": "Unknown"
          }
        ]
      },
      "accuracy_score": 0.75,
      "quality_score": 0.6644,
      "timestamp": "2026-01-25T17:37:28.708029200+00:00"
    },
    {
      "model_name": "qwen2.5-coder:7b",
      "query": "How does the LPC object inheritance system work?",
      "response": "The LPC object inheritance system is a fundamental aspect of MUD (Multi-User Dungeon) game development, allowing developers to create complex and reusable code structures through class-based inheritance. Below is a simplified example of how an LPC-like object inheritance system might be implemented in C, following the patterns shown in the provided references.\n\n### Object Structure\n\nFirst, we define the basic structure for an object, which includes properties, methods, and a reference to its parent object.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PROPS 100\n#define MAX_METHODS 100\n\ntypedef struct {\n    char *name;\n    void *data;\n} Property;\n\ntypedef struct {\n    char *name;\n    void (*func)(void);\n} Method;\n\ntypedef struct Object {\n    char *name;\n    Property props[MAX_PROPS];\n    int prop_count;\n    Method methods[MAX_METHODS];\n    int method_count;\n    struct Object *parent;\n} Object;\n```\n\n### Creating and Initializing Objects\n\nNext, we create functions to initialize objects and set their properties and methods.\n\n```c\nObject* create_object(const char *name) {\n    Object *obj = (Object *)malloc(sizeof(Object));\n    obj->name = strdup(name);\n    obj->prop_count = 0;\n    obj->method_count = 0;\n    obj->parent = NULL;\n    return obj;\n}\n\nvoid add_property(Object *obj, const char *name, void *data) {\n    if (obj->prop_count < MAX_PROPS) {\n        obj->props[obj->prop_count].name = strdup(name);\n        obj->props[obj->prop_count].data = data;\n        obj->prop_count++;\n    }\n}\n\nvoid add_method(Object *obj, const char *name, void (*func)(void)) {\n    if (obj->method_count < MAX_METHODS) {\n        obj->methods[obj->method_count].name = strdup(name);\n        obj->methods[obj->method_count].func = func;\n        obj->method_count++;\n    }\n}\n\nvoid set_parent(Object *child, Object *parent) {\n    child->parent = parent;\n}\n```\n\n### Inheriting Properties and Methods\n\nTo implement inheritance, we need a function that copies properties and methods from the parent object to the child object.\n\n```c\nvoid inherit_object(Object *child, Object *parent) {\n    for (int i = 0; i < parent->prop_count; i++) {\n        add_property(child, parent->props[i].name, parent->props[i].data);\n    }\n    for (int i = 0; i < parent->method_count; i++) {\n        add_method(child, parent->methods[i].name, parent->methods[i].func);\n    }\n}\n```\n\n### Example Usage\n\nFinally, we demonstrate how to create a base object and an inheriting object.\n\n```c\nvoid base_method(void) {\n    printf(\"Base method called\\n\");\n}\n\nint main() {\n    Object *base = create_object(\"BaseObject\");\n    add_property(base, \"base_prop\", (void *)42);\n    add_method(base, \"method\", base_method);\n\n    Object *child = create_object(\"ChildObject\");\n    inherit_object(child, base);\n    set_parent(child, base);\n\n    // Access inherited property and method\n    printf(\"Inherited property: %d\\n\", *(int *)child->props[0].data);\n    child->methods[0].func();\n\n    free(base->name);\n    for (int i = 0; i < base->prop_count; i++) {\n        free(base->props[i].name);\n    }\n    free(base);\n\n    free(child->name);\n    for (int i = 0; i < child->prop_count; i++) {\n        free(child->props[i].name);\n    }\n    free(child);\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Object Structure**: Defines the basic structure of an object, including properties and methods.\n2. **Creating Objects**: Functions to create new objects and add properties and methods.\n3. **Inheritance**: Function to inherit properties and methods from a parent object.\n4. **Example Usage**: Demonstrates creating a base object, inheriting it, and accessing inherited properties and methods.\n\nThis example provides a basic framework for an LPC-like object inheritance system in C. Depending on the complexity of your MUD game, you may need to extend this with more features such as method overriding, dynamic property types, and more sophisticated memory management.",
      "response_time_ms": 22809,
      "tokens_per_second": 27.29959,
      "validation_result": {
        "query": "How does the LPC object inheritance system work?",
        "retrieved_documents": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "line_number": 1299,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1376,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "line_number": 1383,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "line_number": 1455,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "line_number": 1462,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "line_number": 1550,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "line_number": 1643,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "line_number": 1655,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "line_number": 1816,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "line_number": 1836,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "line_number": 1877,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "line_number": 1878,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "line_number": 1962,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "line_number": 1982,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "line_number": 2018,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "relevance_score": 0.6,
            "snippet": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "line_number": 2073,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "line_number": 8,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "line_number": 11,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "line_number": 78,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "line_number": 107,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "relevance_score": 0.6,
            "snippet": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "line_number": 191,
            "validation_status": "CrossReferenced"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "relevance_score": 0.6,
            "snippet": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "line_number": 1,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "line_number": 50,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "relevance_score": 0.6,
            "snippet": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "line_number": 79,
            "validation_status": "SingleSource"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "relevance_score": 0.6,
            "snippet": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "line_number": 17,
            "validation_status": "SingleSource"
          }
        ],
        "confidence_score": 0.61800015,
        "validation_score": 0.33600003,
        "sources_consulted": 25,
        "efuns_found": [
          "ADD",
          "GE",
          "OR",
          "s",
          "t"
        ],
        "code_examples": [
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n    return 0;\n}\n#endif\n\nvoid\nrestore_object_from_buff (object_t * ob, char * theBuff,\n                            int noclear)\n{\n    char *buff, *nextBuff, *tmp;\n\n    nextBuff = theBuff;\n    while ((buff = nextBuff) && *buff) {",
            "context": "From FluffOS at line 1299",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "\n        // Try not to malloc/free too much.\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1376",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        /* FIXME: shouldn't use fprintf() */\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n            textsize += theSize;\n            textsize += strlen(prog->variable_table[i]);\n            textsize += 2;\n#ifdef HAVE_ZLIB",
            "context": "From FluffOS at line 1383",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        // Try not to malloc/free too much.\n\n        if (theSize > oldSize) {\n            if (new_str) {\n                FREE(new_str);\n            }\n        new_str = (char *)DXALLOC(theSize, TAG_TEMPORARY, \"save_object: 2\");\n            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);",
            "context": "From FluffOS at line 1455",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "            oldSize = theSize;\n        }\n\n        *new_str = '\\0';\n        p = new_str;\n        save_svalue((*svp)++, &p);\n        DEBUG_CHECK(p - new_str != theSize - 1, \"Length miscalculated in save_object!\");\n        if (save_zeros || new_str[0] != '0' || new_str[1] != 0) { /* Armidale */\n        \tif (sprintf(buf+textsize-1, \"%s %s\\n\", prog->variable_table[i], new_str) < 0) {\n        \t\tdebug_perror(\"save_object: fprintf\", 0);\n        \t    FREE(new_str);\n        \t    return 0;\n        \t}",
            "context": "From FluffOS at line 1462",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    p = save_name + strlen(save_name) - 1;\n    if (*p != 'c' && *(p - 1) != '.')\n        strcat(p, \".c\");\n\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    sprintf(tmp_name, \"%.250s.tmp\", file);\n\n#ifdef HAVE_ZLIB\n    gzf = NULL;\n    f = NULL;",
            "context": "From FluffOS at line 1550",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    now = now + strlen(now);\n\t*now++ = '\\n';\n\tleft = size - (now - saved);\n\t*now = 0;\n    /*\n     * Write the save-files to different directories, just in case\n     * they are on different file systems.\n     */\n    v = ob->variables;\n    success = save_object_recurse_str(ob->prog, &v, 0, save_zeros, now, left);\n\n    if (!success) {\n        debug_message(\"Failed to completely save file. string size too small?.\\n\");",
            "context": "From FluffOS at line 1643",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "        debug_message(\"Failed to completely save file. string size too small?.\\n\");\n    }\n    return success;\n}\n\n/*\n * return a string representing an svalue in the form that save_object()\n * would write it.\n */\nchar *\nsave_variable (svalue_t * var)\n{\n    int theSize;",
            "context": "From FluffOS at line 1655",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    }\n\n    if (tmp_len > buff_len) {\n        if (theBuff) {\n            FREE(theBuff);\n        }\n        theBuff = DXALLOC(tmp_len + 1, TAG_TEMPORARY, \"restore_object: 4\");\n        buff_len = tmp_len;\n    }\n#ifdef WIN32\n    tmp_len = read(_fileno(f), theBuff, tmp_len);\n#else\n    fread(theBuff, 1, tmp_len, f);",
            "context": "From FluffOS at line 1816",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "     * If 'noclear' flag is not set, all non-static variables will be\n     * initialized to 0 when restored.\n     */\n    if (!noclear)\n        clear_non_statics(ob);\n\n    restore_object_from_buff(ob, theBuff, noclear);\n#endif\n    current_object = save;\n    debug(d_flag, (\"Object /%s restored from /%s.\\n\", ob->obname, file));\n\n    return 1;\n}",
            "context": "From FluffOS at line 1836",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * tell_object: send a message to an object.\n * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);",
            "context": "From FluffOS at line 1877",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": " * If it is an interactive object, it will go to his\n * screen. Otherwise, it will go to a local function\n * catch_tell() in that object. This enables communications\n * between users and NPC's, and between other NPC's.\n * If INTERACTIVE_CATCH_TELL is defined then the message always\n * goes to catch_tell unless the target of tell_object is interactive\n * and is the current_object in which case it is written via add_message().\n */\nvoid tell_object (object_t * ob, const char * str, int len)\n{\n    if (!ob || (ob->flags & O_DESTRUCTED)) {\n        add_message(0, str, len);\n        return;",
            "context": "From FluffOS at line 1878",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    tot_alloc_object--;\n    FREE((char *) ob);\n}\n\nvoid free_object (object_t ** ob, const char * const from)\n{\n    //note that we get a pointer to a pointer unlike MudOS where it's a pointer to the object\n\t//this is so we can clear the variable holding the reference as that shouldn't be used anymore\n\t//after freeing it! don't set to NULL as that might still hide such bugs, and I suspect it may\n\t//be related to some of the corrupted memory crashes (which dw stopped doing, oh well, I'm sure it\n\t//will be back.) Better to find and fix than to hide!\n  if(*ob)\n    (*ob)->ref--;",
            "context": "From FluffOS at line 1962",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "}\n\n/*\n * Allocate an empty object, and set all variables to 0. Note that a\n * 'object_t' already has space for one variable. So, if no variables\n * are needed, we waste one svalue worth of memory (or we'd write too\n * much memory in copying the NULL_object over.\n */\nobject_t *get_empty_object (int num_var)\n{\n  //static object_t NULL_object;\n    object_t *ob;\n    int size = sizeof(object_t) +",
            "context": "From FluffOS at line 1982",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    /* Be sure to update time first ! */\n    ob->next_reset = current_time + TIME_TO_RESET / 2 +\n        random_number(TIME_TO_RESET / 2);\n\n    save_command_giver(0);\n    if (!apply(APPLY_RESET, ob, 0, ORIGIN_DRIVER)) {\n        /* no reset() in the object */\n        ob->flags &= ~O_WILL_RESET;     /* don't call it next time */\n    }\n    restore_command_giver();\n    ob->flags |= O_RESET_STATE;\n}\n",
            "context": "From FluffOS at line 2018",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.c",
            "code": "    if (obj->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(obj);\n    }\n#endif\n\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (obj->shadowed && !obj->shadowing) {\n        object_t *ob2;\n        object_t *otmp;",
            "context": "From FluffOS at line 2073",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/* It is usually better to include \"lpc_incl.h\" instead of including this\n   file directly */\n\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.",
            "context": "From FluffOS at line 8",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "\n/*\n * Definition of an object.\n * If the object is inherited, then it must not be destructed !\n *\n * The reset is used as follows:\n * 0: There is an error in the reset() in this object. Never call it again.\n * 1: Normal state.\n * 2 or higher: This is an interactive user, that has not given any commands\n *              for a number of reset periods.\n */\n\n#include \"packages/uids.h\"",
            "context": "From FluffOS at line 11",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifdef DEBUG\n    unsigned int extra_ref;     /* Used to check ref count. */\n#endif\n    const char * const obname;\n    struct object_s *next_hash;\n    struct object_s *next_ch_hash;\n    /* the fields above must match lpc_object_t */\n    int load_time;              /* time when this object was created */\n#ifndef NO_RESET\n    int next_reset;             /* Time of next reset of this object */\n#endif\n    int time_of_ref;            /* Time when last referenced. Used by clean_uo */\n    program_t *prog;",
            "context": "From FluffOS at line 78",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "#ifndef NO_ADD_ACTION\n    sentence_t *sent;\n    struct object_s *next_hashed_living;\n    char *living_name;          /* Name of living object if in hash */\n#endif\n#ifdef PACKAGE_UIDS\n    userid_t *uid;              /* the \"owner\" of this object */\n    userid_t *euid;             /* the effective \"owner\" */\n#endif\n#ifdef PRIVS\n    char *privs;                /* object's privledges */\n#endif                          /* PRIVS */\n#ifdef PACKAGE_MUDLIB_STATS",
            "context": "From FluffOS at line 107",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\object.h",
            "code": "void mark_command_giver_stack (void);\n#endif\nvoid save_command_giver (object_t *);\nvoid restore_command_giver (void);\nvoid set_command_giver (object_t *);\nvoid clear_non_statics (object_t * ob);\nvoid restore_object_from_buff (object_t * ob, char * theBuff, int noclear);\n#endif",
            "context": "From FluffOS at line 191",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\base.c",
            "code": "// set to 'private static' so that inheritor won't be able to directly\n// access this variable and so that save_object() won't save it to the .o file\n\nprivate staticv string *ids;\n\nvoid\nremove()\n{",
            "context": "From FluffOS at line 1",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "\tif ((name == \"move_object\") && (file != BASE))\n\t\treturn 0;\n//  may also wish to protect destruct, shutdown, snoop, and exec.\n\treturn 1;\n}\n\n// valid_seteuid: determines whether an object ob can become euid str.\n// returns: 1 if seteuid() may succeed, 0 if not.\n\nint\nvalid_seteuid(object, string)\n{\n    return 1;",
            "context": "From FluffOS at line 50",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\inherit\\master\\valid.c",
            "code": "{\n\treturn 1;\n}\n\n// Write and Read privileges:\n//\n// valid_write: called with the file name, the object initiating the call,\n//  and the function by which they called it. \n// return: 1 if access allowed, 0 if access not allowed.\n\nint\nvalid_write(string, mixed, string)\n{",
            "context": "From FluffOS at line 79",
            "driver": "FluffOS"
          },
          {
            "path": "E:\\Work\\lpc-development-assistant\\mud-references\\ds3.8.2\\ds3.8.2\\fluffos-2.23-ds03\\testsuite\\single\\tests\\efuns\\call_other.c",
            "code": "\nvoid do_tests() {\n    ASSERT(file_name()->foo());\n    ASSERT(this_object()->foo());\n    ASSERT(same((mixed *)({ file_name(), this_object() })->foo(), ({ 1, 1 })));\n\n    ASSERT(catch(call_other(this_object(), 0)));\n    ASSERT(call_other(this_object(), \"foo\"));\n    ASSERT(call_other(this_object(), ({ \"foo\", 1 })));\n    ASSERT(catch(call_other(\"foadf\", \"foo\")));\n    \n    ASSERT(undefinedp(this_object()->bazz()));\n    destruct(this_object());",
            "context": "From FluffOS at line 17",
            "driver": "FluffOS"
          }
        ]
      },
      "accuracy_score": 0.5,
      "quality_score": 0.7082572,
      "timestamp": "2026-01-25T17:37:51.517934+00:00"
    }
  ],
  "summary": {
    "best_accuracy": "qwen2.5-coder:3b",
    "best_speed": "qwen2.5-coder:1.5b",
    "best_quality": "qwen2.5-coder:7b",
    "recommended_model": "qwen2.5-coder:3b",
    "reasoning": "Based on testing: qwen2.5-coder:3b achieved highest accuracy (85.0%), qwen2.5-coder:1.5b was fastest (avg 15112ms), qwen2.5-coder:7b had best quality score (71.4%). Recommended model balances all factors."
  }
}